diff --git a/base/BUILD.gn b/base/BUILD.gn
index 46ee3376..49b4801 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1500,6 +1500,22 @@
         "allocator/partition_allocator/page_allocator_internal.h",
         "allocator/partition_allocator/partition_alloc.cc",
         "allocator/partition_allocator/partition_alloc.h",
+        "allocator/partition_allocator/partition_alloc_constants.h",
+        "allocator/partition_allocator/partition_bucket-inl.h",
+        "allocator/partition_allocator/partition_bucket.cc",
+        "allocator/partition_allocator/partition_bucket.h",
+        "allocator/partition_allocator/partition_cookie.h",
+        "allocator/partition_allocator/partition_direct_map_extent-inl.h",
+        "allocator/partition_allocator/partition_direct_map_extent.h",
+        "allocator/partition_allocator/partition_freelist_entry.h",
+        "allocator/partition_allocator/partition_oom.cc",
+        "allocator/partition_allocator/partition_oom.h",
+        "allocator/partition_allocator/partition_page-inl.h",
+        "allocator/partition_allocator/partition_page.cc",
+        "allocator/partition_allocator/partition_page.h",
+        "allocator/partition_allocator/partition_root_base-inl.h",
+        "allocator/partition_allocator/partition_root_base.cc",
+        "allocator/partition_allocator/partition_root_base.h",
         "allocator/partition_allocator/spin_lock.cc",
         "allocator/partition_allocator/spin_lock.h",
       ]
diff --git a/base/allocator/partition_allocator/page_allocator.h b/base/allocator/partition_allocator/page_allocator.h
index b1afb77..c05d993 100644
--- a/base/allocator/partition_allocator/page_allocator.h
+++ b/base/allocator/partition_allocator/page_allocator.h
@@ -9,36 +9,13 @@
 
 #include <cstddef>
 
+#include "base/allocator/partition_allocator/page_allocator_constants.h"
 #include "base/base_export.h"
 #include "base/compiler_specific.h"
 #include "build/build_config.h"
 
 namespace base {
 
-#if defined(OS_WIN)
-static const size_t kPageAllocationGranularityShift = 16;  // 64KB
-#elif defined(_MIPS_ARCH_LOONGSON)
-static const size_t kPageAllocationGranularityShift = 14;  // 16KB
-#else
-static const size_t kPageAllocationGranularityShift = 12;  // 4KB
-#endif
-static const size_t kPageAllocationGranularity =
-    1 << kPageAllocationGranularityShift;
-static const size_t kPageAllocationGranularityOffsetMask =
-    kPageAllocationGranularity - 1;
-static const size_t kPageAllocationGranularityBaseMask =
-    ~kPageAllocationGranularityOffsetMask;
-
-#if defined(_MIPS_ARCH_LOONGSON)
-static const size_t kSystemPageSize = 16384;
-#else
-static const size_t kSystemPageSize = 4096;
-#endif
-static const size_t kSystemPageOffsetMask = kSystemPageSize - 1;
-static_assert((kSystemPageSize & (kSystemPageSize - 1)) == 0,
-              "kSystemPageSize must be power of 2");
-static const size_t kSystemPageBaseMask = ~kSystemPageOffsetMask;
-
 enum PageAccessibilityConfiguration {
   PageInaccessible,
   PageRead,
diff --git a/base/allocator/partition_allocator/page_allocator_constants.h b/base/allocator/partition_allocator/page_allocator_constants.h
new file mode 100644
index 0000000..7eabc66
--- /dev/null
+++ b/base/allocator/partition_allocator/page_allocator_constants.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_CONSTANTS_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_CONSTANTS_H_
+
+#include <stddef.h>
+
+#include "build/build_config.h"
+
+namespace base {
+#if defined(OS_WIN)
+static const size_t kPageAllocationGranularityShift = 16;  // 64KB
+#elif defined(_MIPS_ARCH_LOONGSON)
+static const size_t kPageAllocationGranularityShift = 14;  // 16KB
+#else
+static const size_t kPageAllocationGranularityShift = 12;  // 4KB
+#endif
+static const size_t kPageAllocationGranularity =
+    1 << kPageAllocationGranularityShift;
+static const size_t kPageAllocationGranularityOffsetMask =
+    kPageAllocationGranularity - 1;
+static const size_t kPageAllocationGranularityBaseMask =
+    ~kPageAllocationGranularityOffsetMask;
+
+#if defined(_MIPS_ARCH_LOONGSON)
+static const size_t kSystemPageSize = 16384;
+#else
+static const size_t kSystemPageSize = 4096;
+#endif
+static const size_t kSystemPageOffsetMask = kSystemPageSize - 1;
+static_assert((kSystemPageSize & (kSystemPageSize - 1)) == 0,
+              "kSystemPageSize must be power of 2");
+static const size_t kSystemPageBaseMask = ~kSystemPageOffsetMask;
+
+static const size_t kPageMetadataShift = 5;  // 32 bytes per partition page.
+static const size_t kPageMetadataSize = 1 << kPageMetadataShift;
+
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_CONSTANTS_H
diff --git a/base/allocator/partition_allocator/partition_alloc.cc b/base/allocator/partition_allocator/partition_alloc.cc
index 0c4b91f..069ac03 100644
--- a/base/allocator/partition_allocator/partition_alloc.cc
+++ b/base/allocator/partition_allocator/partition_alloc.cc
@@ -7,7 +7,9 @@
 #include <string.h>
 #include <type_traits>
 
-#include "base/allocator/partition_allocator/oom.h"
+#include "base/allocator/partition_allocator/partition_direct_map_extent-inl.h"
+#include "base/allocator/partition_allocator/partition_oom.h"
+#include "base/allocator/partition_allocator/partition_page-inl.h"
 #include "base/allocator/partition_allocator/spin_lock.h"
 #include "base/compiler_specific.h"
 #include "base/lazy_instance.h"
@@ -24,11 +26,12 @@
               "ok partition page size");
 static_assert(!(base::kPartitionPageSize % base::kSystemPageSize),
               "ok partition page multiple");
-static_assert(sizeof(base::PartitionPage) <= base::kPageMetadataSize,
+static_assert(sizeof(base::internal::PartitionPage) <= base::kPageMetadataSize,
               "PartitionPage should not be too big");
-static_assert(sizeof(base::PartitionBucket) <= base::kPageMetadataSize,
+static_assert(sizeof(base::internal::PartitionBucket) <=
+                  base::kPageMetadataSize,
               "PartitionBucket should not be too big");
-static_assert(sizeof(base::PartitionSuperPageExtentEntry) <=
+static_assert(sizeof(base::internal::PartitionSuperPageExtentEntry) <=
                   base::kPageMetadataSize,
               "PartitionSuperPageExtentEntry should not be too big");
 static_assert(base::kPageMetadataSize * base::kNumPartitionPagesPerSuperPage <=
@@ -46,19 +49,8 @@
 
 namespace base {
 
-namespace {
-
-// g_sentinel_page is used as a sentinel to indicate that there is no page
-// in the active page list. We can use nullptr, but in that case we need
-// to add a null-check branch to the hot allocation path. We want to avoid
-// that.
-PartitionPage g_sentinel_page;
-PartitionBucket g_sentinel_bucket;
-
-}  // namespace
-
-PartitionRootBase::PartitionRootBase() = default;
-PartitionRootBase::~PartitionRootBase() = default;
+internal::PartitionRootBase::PartitionRootBase() = default;
+internal::PartitionRootBase::~PartitionRootBase() = default;
 PartitionRoot::PartitionRoot() = default;
 PartitionRoot::~PartitionRoot() = default;
 PartitionRootGeneric::PartitionRootGeneric() = default;
@@ -70,74 +62,12 @@
     LAZY_INSTANCE_INITIALIZER;
 static bool g_initialized = false;
 
-void (*PartitionRootBase::gOomHandlingFunction)() = nullptr;
+void (*internal::PartitionRootBase::gOomHandlingFunction)() = nullptr;
 PartitionAllocHooks::AllocationHook* PartitionAllocHooks::allocation_hook_ =
     nullptr;
 PartitionAllocHooks::FreeHook* PartitionAllocHooks::free_hook_ = nullptr;
 
-// TODO(ajwong): This seems to interact badly with
-// get_pages_per_slot_span() which rounds the value from this up to a
-// multiple of kNumSystemPagesPerPartitionPage (aka 4) anyways.
-// http://crbug.com/776537
-//
-// TODO(ajwong): The waste calculation seems wrong. The PTE usage should cover
-// both used and unsed pages.
-// http://crbug.com/776537
-uint8_t PartitionBucket::get_system_pages_per_slot_span() {
-  // This works out reasonably for the current bucket sizes of the generic
-  // allocator, and the current values of partition page size and constants.
-  // Specifically, we have enough room to always pack the slots perfectly into
-  // some number of system pages. The only waste is the waste associated with
-  // unfaulted pages (i.e. wasted address space).
-  // TODO: we end up using a lot of system pages for very small sizes. For
-  // example, we'll use 12 system pages for slot size 24. The slot size is
-  // so small that the waste would be tiny with just 4, or 1, system pages.
-  // Later, we can investigate whether there are anti-fragmentation benefits
-  // to using fewer system pages.
-  double best_waste_ratio = 1.0f;
-  uint16_t best_pages = 0;
-  if (this->slot_size > kMaxSystemPagesPerSlotSpan * kSystemPageSize) {
-    // TODO(ajwong): Why is there a DCHECK here for this?
-    // http://crbug.com/776537
-    DCHECK(!(this->slot_size % kSystemPageSize));
-    best_pages = static_cast<uint16_t>(this->slot_size / kSystemPageSize);
-    // TODO(ajwong): Should this be checking against
-    // kMaxSystemPagesPerSlotSpan or numeric_limits<uint8_t>::max?
-    // http://crbug.com/776537
-    CHECK(best_pages < (1 << 8));
-    return static_cast<uint8_t>(best_pages);
-  }
-  DCHECK(this->slot_size <= kMaxSystemPagesPerSlotSpan * kSystemPageSize);
-  for (uint16_t i = kNumSystemPagesPerPartitionPage - 1;
-       i <= kMaxSystemPagesPerSlotSpan; ++i) {
-    size_t page_size = kSystemPageSize * i;
-    size_t num_slots = page_size / this->slot_size;
-    size_t waste = page_size - (num_slots * this->slot_size);
-    // Leaving a page unfaulted is not free; the page will occupy an empty page
-    // table entry.  Make a simple attempt to account for that.
-    //
-    // TODO(ajwong): This looks wrong. PTEs are allocated for all pages
-    // regardless of whether or not they are wasted. Should it just
-    // be waste += i * sizeof(void*)?
-    // http://crbug.com/776537
-    size_t num_remainder_pages = i & (kNumSystemPagesPerPartitionPage - 1);
-    size_t num_unfaulted_pages =
-        num_remainder_pages
-            ? (kNumSystemPagesPerPartitionPage - num_remainder_pages)
-            : 0;
-    waste += sizeof(void*) * num_unfaulted_pages;
-    double waste_ratio = (double)waste / (double)page_size;
-    if (waste_ratio < best_waste_ratio) {
-      best_waste_ratio = waste_ratio;
-      best_pages = i;
-    }
-  }
-  DCHECK(best_pages > 0);
-  CHECK(best_pages <= kMaxSystemPagesPerSlotSpan);
-  return static_cast<uint8_t>(best_pages);
-}
-
-static void PartitionAllocBaseInit(PartitionRootBase* root) {
+static void PartitionAllocBaseInit(internal::PartitionRootBase* root) {
   DCHECK(!root->initialized);
   {
     subtle::SpinLock::Guard guard(g_initialized_lock.Get());
@@ -145,7 +75,8 @@
       g_initialized = true;
       // We mark the sentinel bucket/page as free to make sure it is skipped by
       // our logic to find a new active page.
-      g_sentinel_bucket.active_pages_head = &g_sentinel_page;
+      internal::PartitionBucket::get_sentinel_bucket()->active_pages_head =
+          internal::PartitionPage::get_sentinel_page();
     }
   }
 
@@ -155,18 +86,9 @@
   root->inverted_self = ~reinterpret_cast<uintptr_t>(root);
 }
 
-void PartitionBucket::Init(uint32_t new_slot_size) {
-  slot_size = new_slot_size;
-  active_pages_head = &g_sentinel_page;
-  empty_pages_head = nullptr;
-  decommitted_pages_head = nullptr;
-  num_full_pages = 0;
-  num_system_pages_per_slot_span = get_system_pages_per_slot_span();
-}
-
 void PartitionAllocGlobalInit(void (*oom_handling_function)()) {
   DCHECK(oom_handling_function);
-  PartitionRootBase::gOomHandlingFunction = oom_handling_function;
+  internal::PartitionRootBase::gOomHandlingFunction = oom_handling_function;
 }
 
 void PartitionRoot::Init(size_t num_buckets, size_t max_allocation) {
@@ -176,7 +98,7 @@
   this->max_allocation = max_allocation;
   size_t i;
   for (i = 0; i < this->num_buckets; ++i) {
-    PartitionBucket* bucket = &this->buckets()[i];
+    internal::PartitionBucket* bucket = &this->buckets()[i];
     if (!i)
       bucket->Init(kAllocationGranularity);
     else
@@ -226,7 +148,7 @@
   size_t current_size = kGenericSmallestBucket;
   size_t currentIncrement =
       kGenericSmallestBucket >> kGenericNumBucketsPerOrderBits;
-  PartitionBucket* bucket = &this->buckets[0];
+  internal::PartitionBucket* bucket = &this->buckets[0];
   for (i = 0; i < kGenericNumBucketedOrders; ++i) {
     for (j = 0; j < kGenericNumBucketsPerOrder; ++j) {
       bucket->Init(current_size);
@@ -243,16 +165,16 @@
 
   // Then set up the fast size -> bucket lookup table.
   bucket = &this->buckets[0];
-  PartitionBucket** bucketPtr = &this->bucket_lookups[0];
+  internal::PartitionBucket** bucketPtr = &this->bucket_lookups[0];
   for (order = 0; order <= kBitsPerSizeT; ++order) {
     for (j = 0; j < kGenericNumBucketsPerOrder; ++j) {
       if (order < kGenericMinBucketedOrder) {
         // Use the bucket of the finest granularity for malloc(0) etc.
         *bucketPtr++ = &this->buckets[0];
       } else if (order > kGenericMaxBucketedOrder) {
-        *bucketPtr++ = PartitionBucket::get_sentinel_bucket();
+        *bucketPtr++ = internal::PartitionBucket::get_sentinel_bucket();
       } else {
-        PartitionBucket* validBucket = bucket;
+        internal::PartitionBucket* validBucket = bucket;
         // Skip over invalid buckets.
         while (validBucket->slot_size % kGenericSmallestBucket)
           validBucket++;
@@ -266,743 +188,19 @@
                           ((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder));
   // And there's one last bucket lookup that will be hit for e.g. malloc(-1),
   // which tries to overflow to a non-existant order.
-  *bucketPtr = PartitionBucket::get_sentinel_bucket();
-}
-
-#if !defined(ARCH_CPU_64_BITS)
-static NOINLINE void PartitionOutOfMemoryWithLotsOfUncommitedPages() {
-  OOM_CRASH();
-}
-#endif
-
-static NOINLINE void PartitionOutOfMemory(const PartitionRootBase* root) {
-#if !defined(ARCH_CPU_64_BITS)
-  // Check whether this OOM is due to a lot of super pages that are allocated
-  // but not committed, probably due to http://crbug.com/421387.
-  if (root->total_size_of_super_pages +
-          root->total_size_of_direct_mapped_pages -
-          root->total_size_of_committed_pages >
-      kReasonableSizeOfUnusedPages) {
-    PartitionOutOfMemoryWithLotsOfUncommitedPages();
-  }
-#endif
-  if (PartitionRootBase::gOomHandlingFunction)
-    (*PartitionRootBase::gOomHandlingFunction)();
-  OOM_CRASH();
-}
-
-static NOINLINE void PartitionExcessiveAllocationSize() {
-  OOM_CRASH();
-}
-
-NOINLINE void PartitionBucket::OnFull() {
-  OOM_CRASH();
-}
-
-ALWAYS_INLINE bool PartitionPage::is_active() const {
-  DCHECK(this != &g_sentinel_page);
-  DCHECK(!page_offset);
-  return (num_allocated_slots > 0 &&
-          (freelist_head || num_unprovisioned_slots));
-}
-
-ALWAYS_INLINE bool PartitionPage::is_full() const {
-  DCHECK(this != &g_sentinel_page);
-  DCHECK(!page_offset);
-  bool ret = (num_allocated_slots == bucket->get_slots_per_span());
-  if (ret) {
-    DCHECK(!freelist_head);
-    DCHECK(!num_unprovisioned_slots);
-  }
-  return ret;
-}
-
-ALWAYS_INLINE bool PartitionPage::is_empty() const {
-  DCHECK(this != &g_sentinel_page);
-  DCHECK(!page_offset);
-  return (!num_allocated_slots && freelist_head);
-}
-
-ALWAYS_INLINE bool PartitionPage::is_decommitted() const {
-  DCHECK(this != &g_sentinel_page);
-  DCHECK(!page_offset);
-  bool ret = (!num_allocated_slots && !freelist_head);
-  if (ret) {
-    DCHECK(!num_unprovisioned_slots);
-    DCHECK(empty_cache_index == -1);
-  }
-  return ret;
-}
-
-static void PartitionIncreaseCommittedPages(PartitionRootBase* root,
-                                            size_t len) {
-  root->total_size_of_committed_pages += len;
-  DCHECK(root->total_size_of_committed_pages <=
-         root->total_size_of_super_pages +
-             root->total_size_of_direct_mapped_pages);
-}
-
-static void PartitionDecreaseCommittedPages(PartitionRootBase* root,
-                                            size_t len) {
-  root->total_size_of_committed_pages -= len;
-  DCHECK(root->total_size_of_committed_pages <=
-         root->total_size_of_super_pages +
-             root->total_size_of_direct_mapped_pages);
-}
-
-static ALWAYS_INLINE void PartitionDecommitSystemPages(PartitionRootBase* root,
-                                                       void* address,
-                                                       size_t length) {
-  DecommitSystemPages(address, length);
-  PartitionDecreaseCommittedPages(root, length);
-}
-
-static ALWAYS_INLINE void PartitionRecommitSystemPages(PartitionRootBase* root,
-                                                       void* address,
-                                                       size_t length) {
-  CHECK(RecommitSystemPages(address, length, PageReadWrite));
-  PartitionIncreaseCommittedPages(root, length);
-}
-
-ALWAYS_INLINE void* PartitionBucket::AllocNewSlotSpan(
-    PartitionRootBase* root,
-    int flags,
-    uint16_t num_partition_pages) {
-  DCHECK(!(reinterpret_cast<uintptr_t>(root->next_partition_page) %
-           kPartitionPageSize));
-  DCHECK(!(reinterpret_cast<uintptr_t>(root->next_partition_page_end) %
-           kPartitionPageSize));
-  DCHECK(num_partition_pages <= kNumPartitionPagesPerSuperPage);
-  size_t total_size = kPartitionPageSize * num_partition_pages;
-  size_t num_partition_pages_left =
-      (root->next_partition_page_end - root->next_partition_page) >>
-      kPartitionPageShift;
-  if (LIKELY(num_partition_pages_left >= num_partition_pages)) {
-    // In this case, we can still hand out pages from the current super page
-    // allocation.
-    char* ret = root->next_partition_page;
-
-    // Fresh System Pages in the SuperPages are decommited. Commit them
-    // before vending them back.
-    CHECK(SetSystemPagesAccess(ret, total_size, PageReadWrite));
-
-    root->next_partition_page += total_size;
-    PartitionIncreaseCommittedPages(root, total_size);
-    return ret;
-  }
-
-  // Need a new super page. We want to allocate super pages in a continguous
-  // address region as much as possible. This is important for not causing
-  // page table bloat and not fragmenting address spaces in 32 bit
-  // architectures.
-  char* requestedAddress = root->next_super_page;
-  char* super_page = reinterpret_cast<char*>(AllocPages(
-      requestedAddress, kSuperPageSize, kSuperPageSize, PageReadWrite));
-  if (UNLIKELY(!super_page))
-    return nullptr;
-
-  root->total_size_of_super_pages += kSuperPageSize;
-  PartitionIncreaseCommittedPages(root, total_size);
-
-  // |total_size| MUST be less than kSuperPageSize - (kPartitionPageSize*2).
-  // This is a trustworthy value because num_partition_pages is not user
-  // controlled.
-  //
-  // TODO(ajwong): Introduce a DCHECK.
-  root->next_super_page = super_page + kSuperPageSize;
-  char* ret = super_page + kPartitionPageSize;
-  root->next_partition_page = ret + total_size;
-  root->next_partition_page_end = root->next_super_page - kPartitionPageSize;
-  // Make the first partition page in the super page a guard page, but leave a
-  // hole in the middle.
-  // This is where we put page metadata and also a tiny amount of extent
-  // metadata.
-  CHECK(SetSystemPagesAccess(super_page, kSystemPageSize, PageInaccessible));
-  CHECK(SetSystemPagesAccess(super_page + (kSystemPageSize * 2),
-                             kPartitionPageSize - (kSystemPageSize * 2),
-                             PageInaccessible));
-  //  CHECK(SetSystemPagesAccess(super_page + (kSuperPageSize -
-  //  kPartitionPageSize),
-  //                             kPartitionPageSize, PageInaccessible));
-  // All remaining slotspans for the unallocated PartitionPages inside the
-  // SuperPage are conceptually decommitted. Correctly set the state here
-  // so they do not occupy resources.
-  //
-  // TODO(ajwong): Refactor Page Allocator API so the SuperPage comes in
-  // decommited initially.
-  CHECK(SetSystemPagesAccess(super_page + kPartitionPageSize + total_size,
-                             (kSuperPageSize - kPartitionPageSize - total_size),
-                             PageInaccessible));
-
-  // If we were after a specific address, but didn't get it, assume that
-  // the system chose a lousy address. Here most OS'es have a default
-  // algorithm that isn't randomized. For example, most Linux
-  // distributions will allocate the mapping directly before the last
-  // successful mapping, which is far from random. So we just get fresh
-  // randomness for the next mapping attempt.
-  if (requestedAddress && requestedAddress != super_page)
-    root->next_super_page = nullptr;
-
-  // We allocated a new super page so update super page metadata.
-  // First check if this is a new extent or not.
-  PartitionSuperPageExtentEntry* latest_extent =
-      reinterpret_cast<PartitionSuperPageExtentEntry*>(
-          PartitionSuperPageToMetadataArea(super_page));
-  // By storing the root in every extent metadata object, we have a fast way
-  // to go from a pointer within the partition to the root object.
-  latest_extent->root = root;
-  // Most new extents will be part of a larger extent, and these three fields
-  // are unused, but we initialize them to 0 so that we get a clear signal
-  // in case they are accidentally used.
-  latest_extent->super_page_base = nullptr;
-  latest_extent->super_pages_end = nullptr;
-  latest_extent->next = nullptr;
-
-  PartitionSuperPageExtentEntry* current_extent = root->current_extent;
-  bool isNewExtent = (super_page != requestedAddress);
-  if (UNLIKELY(isNewExtent)) {
-    if (UNLIKELY(!current_extent)) {
-      DCHECK(!root->first_extent);
-      root->first_extent = latest_extent;
-    } else {
-      DCHECK(current_extent->super_page_base);
-      current_extent->next = latest_extent;
-    }
-    root->current_extent = latest_extent;
-    latest_extent->super_page_base = super_page;
-    latest_extent->super_pages_end = super_page + kSuperPageSize;
-  } else {
-    // We allocated next to an existing extent so just nudge the size up a
-    // little.
-    DCHECK(current_extent->super_pages_end);
-    current_extent->super_pages_end += kSuperPageSize;
-    DCHECK(ret >= current_extent->super_page_base &&
-           ret < current_extent->super_pages_end);
-  }
-  return ret;
-}
-
-ALWAYS_INLINE uint16_t PartitionBucket::get_pages_per_slot_span() {
-  // Rounds up to nearest multiple of kNumSystemPagesPerPartitionPage.
-  return (num_system_pages_per_slot_span +
-          (kNumSystemPagesPerPartitionPage - 1)) /
-         kNumSystemPagesPerPartitionPage;
-}
-
-ALWAYS_INLINE void PartitionPage::Reset() {
-  DCHECK(this->is_decommitted());
-
-  num_unprovisioned_slots = bucket->get_slots_per_span();
-  DCHECK(num_unprovisioned_slots);
-
-  next_page = nullptr;
-}
-
-ALWAYS_INLINE void PartitionBucket::InitializeSlotSpan(PartitionPage* page) {
-  // The bucket never changes. We set it up once.
-  page->bucket = this;
-  page->empty_cache_index = -1;
-
-  page->Reset();
-
-  // If this page has just a single slot, do not set up page offsets for any
-  // page metadata other than the first one. This ensures that attempts to
-  // touch invalid page metadata fail.
-  if (page->num_unprovisioned_slots == 1)
-    return;
-
-  uint16_t num_partition_pages = get_pages_per_slot_span();
-  char* page_char_ptr = reinterpret_cast<char*>(page);
-  for (uint16_t i = 1; i < num_partition_pages; ++i) {
-    page_char_ptr += kPageMetadataSize;
-    PartitionPage* secondary_page =
-        reinterpret_cast<PartitionPage*>(page_char_ptr);
-    secondary_page->page_offset = i;
-  }
-}
-
-ALWAYS_INLINE char* PartitionBucket::AllocAndFillFreelist(PartitionPage* page) {
-  DCHECK(page != PartitionPage::get_sentinel_page());
-  uint16_t num_slots = page->num_unprovisioned_slots;
-  DCHECK(num_slots);
-  // We should only get here when _every_ slot is either used or unprovisioned.
-  // (The third state is "on the freelist". If we have a non-empty freelist, we
-  // should not get here.)
-  DCHECK(num_slots + page->num_allocated_slots == this->get_slots_per_span());
-  // Similarly, make explicitly sure that the freelist is empty.
-  DCHECK(!page->freelist_head);
-  DCHECK(page->num_allocated_slots >= 0);
-
-  size_t size = this->slot_size;
-  char* base = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
-  char* return_object = base + (size * page->num_allocated_slots);
-  char* firstFreelistPointer = return_object + size;
-  char* firstFreelistPointerExtent =
-      firstFreelistPointer + sizeof(PartitionFreelistEntry*);
-  // Our goal is to fault as few system pages as possible. We calculate the
-  // page containing the "end" of the returned slot, and then allow freelist
-  // pointers to be written up to the end of that page.
-  char* sub_page_limit = reinterpret_cast<char*>(
-      RoundUpToSystemPage(reinterpret_cast<size_t>(firstFreelistPointer)));
-  char* slots_limit = return_object + (size * num_slots);
-  char* freelist_limit = sub_page_limit;
-  if (UNLIKELY(slots_limit < freelist_limit))
-    freelist_limit = slots_limit;
-
-  uint16_t num_new_freelist_entries = 0;
-  if (LIKELY(firstFreelistPointerExtent <= freelist_limit)) {
-    // Only consider used space in the slot span. If we consider wasted
-    // space, we may get an off-by-one when a freelist pointer fits in the
-    // wasted space, but a slot does not.
-    // We know we can fit at least one freelist pointer.
-    num_new_freelist_entries = 1;
-    // Any further entries require space for the whole slot span.
-    num_new_freelist_entries += static_cast<uint16_t>(
-        (freelist_limit - firstFreelistPointerExtent) / size);
-  }
-
-  // We always return an object slot -- that's the +1 below.
-  // We do not neccessarily create any new freelist entries, because we cross
-  // sub page boundaries frequently for large bucket sizes.
-  DCHECK(num_new_freelist_entries + 1 <= num_slots);
-  num_slots -= (num_new_freelist_entries + 1);
-  page->num_unprovisioned_slots = num_slots;
-  page->num_allocated_slots++;
-
-  if (LIKELY(num_new_freelist_entries)) {
-    char* freelist_pointer = firstFreelistPointer;
-    PartitionFreelistEntry* entry =
-        reinterpret_cast<PartitionFreelistEntry*>(freelist_pointer);
-    page->freelist_head = entry;
-    while (--num_new_freelist_entries) {
-      freelist_pointer += size;
-      PartitionFreelistEntry* next_entry =
-          reinterpret_cast<PartitionFreelistEntry*>(freelist_pointer);
-      entry->next = PartitionFreelistEntry::Transform(next_entry);
-      entry = next_entry;
-    }
-    entry->next = PartitionFreelistEntry::Transform(nullptr);
-  } else {
-    page->freelist_head = nullptr;
-  }
-  return return_object;
-}
-
-bool PartitionBucket::SetNewActivePage() {
-  PartitionPage* page = this->active_pages_head;
-  if (page == PartitionPage::get_sentinel_page())
-    return false;
-
-  PartitionPage* next_page;
-
-  for (; page; page = next_page) {
-    next_page = page->next_page;
-    DCHECK(page->bucket == this);
-    DCHECK(page != this->empty_pages_head);
-    DCHECK(page != this->decommitted_pages_head);
-
-    if (LIKELY(page->is_active())) {
-      // This page is usable because it has freelist entries, or has
-      // unprovisioned slots we can create freelist entries from.
-      this->active_pages_head = page;
-      return true;
-    }
-
-    // Deal with empty and decommitted pages.
-    if (LIKELY(page->is_empty())) {
-      page->next_page = this->empty_pages_head;
-      this->empty_pages_head = page;
-    } else if (LIKELY(page->is_decommitted())) {
-      page->next_page = this->decommitted_pages_head;
-      this->decommitted_pages_head = page;
-    } else {
-      DCHECK(page->is_full());
-      // If we get here, we found a full page. Skip over it too, and also
-      // tag it as full (via a negative value). We need it tagged so that
-      // free'ing can tell, and move it back into the active page list.
-      page->num_allocated_slots = -page->num_allocated_slots;
-      ++this->num_full_pages;
-      // num_full_pages is a uint16_t for efficient packing so guard against
-      // overflow to be safe.
-      if (UNLIKELY(!this->num_full_pages))
-        OnFull();
-      // Not necessary but might help stop accidents.
-      page->next_page = nullptr;
-    }
-  }
-
-  this->active_pages_head = PartitionPage::get_sentinel_page();
-  return false;
-}
-
-ALWAYS_INLINE PartitionDirectMapExtent* PartitionDirectMapExtent::FromPage(
-    PartitionPage* page) {
-  DCHECK(page->bucket->is_direct_mapped());
-  return reinterpret_cast<PartitionDirectMapExtent*>(
-      reinterpret_cast<char*>(page) + 3 * kPageMetadataSize);
-}
-
-ALWAYS_INLINE void PartitionPage::set_raw_size(size_t size) {
-  size_t* raw_size_ptr = get_raw_size_ptr();
-  if (UNLIKELY(raw_size_ptr != nullptr))
-    *raw_size_ptr = size;
-}
-
-static ALWAYS_INLINE PartitionPage* PartitionDirectMap(PartitionRootBase* root,
-                                                       int flags,
-                                                       size_t raw_size) {
-  size_t size = PartitionDirectMapSize(raw_size);
-
-  // Because we need to fake looking like a super page, we need to allocate
-  // a bunch of system pages more than "size":
-  // - The first few system pages are the partition page in which the super
-  // page metadata is stored. We fault just one system page out of a partition
-  // page sized clump.
-  // - We add a trailing guard page on 32-bit (on 64-bit we rely on the
-  // massive address space plus randomization instead).
-  size_t map_size = size + kPartitionPageSize;
-#if !defined(ARCH_CPU_64_BITS)
-  map_size += kSystemPageSize;
-#endif
-  // Round up to the allocation granularity.
-  map_size += kPageAllocationGranularityOffsetMask;
-  map_size &= kPageAllocationGranularityBaseMask;
-
-  // TODO: these pages will be zero-filled. Consider internalizing an
-  // allocZeroed() API so we can avoid a memset() entirely in this case.
-  char* ptr = reinterpret_cast<char*>(
-      AllocPages(nullptr, map_size, kSuperPageSize, PageReadWrite));
-  if (UNLIKELY(!ptr))
-    return nullptr;
-
-  size_t committed_page_size = size + kSystemPageSize;
-  root->total_size_of_direct_mapped_pages += committed_page_size;
-  PartitionIncreaseCommittedPages(root, committed_page_size);
-
-  char* slot = ptr + kPartitionPageSize;
-  CHECK(SetSystemPagesAccess(ptr + (kSystemPageSize * 2),
-                             kPartitionPageSize - (kSystemPageSize * 2),
-                             PageInaccessible));
-#if !defined(ARCH_CPU_64_BITS)
-  CHECK(SetSystemPagesAccess(ptr, kSystemPageSize, PageInaccessible));
-  CHECK(SetSystemPagesAccess(slot + size, kSystemPageSize, PageInaccessible));
-#endif
-
-  PartitionSuperPageExtentEntry* extent =
-      reinterpret_cast<PartitionSuperPageExtentEntry*>(
-          PartitionSuperPageToMetadataArea(ptr));
-  extent->root = root;
-  // The new structures are all located inside a fresh system page so they
-  // will all be zeroed out. These DCHECKs are for documentation.
-  DCHECK(!extent->super_page_base);
-  DCHECK(!extent->super_pages_end);
-  DCHECK(!extent->next);
-  PartitionPage* page = PartitionPage::FromPointerNoAlignmentCheck(slot);
-  PartitionBucket* bucket = reinterpret_cast<PartitionBucket*>(
-      reinterpret_cast<char*>(page) + (kPageMetadataSize * 2));
-  DCHECK(!page->next_page);
-  DCHECK(!page->num_allocated_slots);
-  DCHECK(!page->num_unprovisioned_slots);
-  DCHECK(!page->page_offset);
-  DCHECK(!page->empty_cache_index);
-  page->bucket = bucket;
-  page->freelist_head = reinterpret_cast<PartitionFreelistEntry*>(slot);
-  PartitionFreelistEntry* next_entry =
-      reinterpret_cast<PartitionFreelistEntry*>(slot);
-  next_entry->next = PartitionFreelistEntry::Transform(nullptr);
-
-  DCHECK(!bucket->active_pages_head);
-  DCHECK(!bucket->empty_pages_head);
-  DCHECK(!bucket->decommitted_pages_head);
-  DCHECK(!bucket->num_system_pages_per_slot_span);
-  DCHECK(!bucket->num_full_pages);
-  bucket->slot_size = size;
-
-  PartitionDirectMapExtent* map_extent =
-      PartitionDirectMapExtent::FromPage(page);
-  map_extent->map_size = map_size - kPartitionPageSize - kSystemPageSize;
-  map_extent->bucket = bucket;
-
-  // Maintain the doubly-linked list of all direct mappings.
-  map_extent->next_extent = root->direct_map_list;
-  if (map_extent->next_extent)
-    map_extent->next_extent->prev_extent = map_extent;
-  map_extent->prev_extent = nullptr;
-  root->direct_map_list = map_extent;
-
-  return page;
-}
-
-static ALWAYS_INLINE void PartitionDirectUnmap(PartitionPage* page) {
-  PartitionRootBase* root = PartitionRootBase::FromPage(page);
-  const PartitionDirectMapExtent* extent =
-      PartitionDirectMapExtent::FromPage(page);
-  size_t unmap_size = extent->map_size;
-
-  // Maintain the doubly-linked list of all direct mappings.
-  if (extent->prev_extent) {
-    DCHECK(extent->prev_extent->next_extent == extent);
-    extent->prev_extent->next_extent = extent->next_extent;
-  } else {
-    root->direct_map_list = extent->next_extent;
-  }
-  if (extent->next_extent) {
-    DCHECK(extent->next_extent->prev_extent == extent);
-    extent->next_extent->prev_extent = extent->prev_extent;
-  }
-
-  // Add on the size of the trailing guard page and preceeding partition
-  // page.
-  unmap_size += kPartitionPageSize + kSystemPageSize;
-
-  size_t uncommitted_page_size = page->bucket->slot_size + kSystemPageSize;
-  PartitionDecreaseCommittedPages(root, uncommitted_page_size);
-  DCHECK(root->total_size_of_direct_mapped_pages >= uncommitted_page_size);
-  root->total_size_of_direct_mapped_pages -= uncommitted_page_size;
-
-  DCHECK(!(unmap_size & kPageAllocationGranularityOffsetMask));
-
-  char* ptr = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
-  // Account for the mapping starting a partition page before the actual
-  // allocation address.
-  ptr -= kPartitionPageSize;
-
-  FreePages(ptr, unmap_size);
-}
-
-void* PartitionBucket::SlowPathAlloc(PartitionRootBase* root,
-                                     int flags,
-                                     size_t size) {
-  // The slow path is called when the freelist is empty.
-  DCHECK(!this->active_pages_head->freelist_head);
-
-  PartitionPage* new_page = nullptr;
-
-  // For the PartitionRootGeneric::Alloc() API, we have a bunch of buckets
-  // marked as special cases. We bounce them through to the slow path so that
-  // we can still have a blazing fast hot path due to lack of corner-case
-  // branches.
-  //
-  // Note: The ordering of the conditionals matter! In particular,
-  // SetNewActivePage() has a side-effect even when returning
-  // false where it sweeps the active page list and may move things into
-  // the empty or decommitted lists which affects the subsequent conditional.
-  bool returnNull = flags & PartitionAllocReturnNull;
-  if (UNLIKELY(this->is_direct_mapped())) {
-    DCHECK(size > kGenericMaxBucketed);
-    DCHECK(this == get_sentinel_bucket());
-    DCHECK(this->active_pages_head == &g_sentinel_page);
-    if (size > kGenericMaxDirectMapped) {
-      if (returnNull)
-        return nullptr;
-      PartitionExcessiveAllocationSize();
-    }
-    new_page = PartitionDirectMap(root, flags, size);
-  } else if (LIKELY(this->SetNewActivePage())) {
-    // First, did we find an active page in the active pages list?
-    new_page = this->active_pages_head;
-    DCHECK(new_page->is_active());
-  } else if (LIKELY(this->empty_pages_head != nullptr) ||
-             LIKELY(this->decommitted_pages_head != nullptr)) {
-    // Second, look in our lists of empty and decommitted pages.
-    // Check empty pages first, which are preferred, but beware that an
-    // empty page might have been decommitted.
-    while (LIKELY((new_page = this->empty_pages_head) != nullptr)) {
-      DCHECK(new_page->bucket == this);
-      DCHECK(new_page->is_empty() || new_page->is_decommitted());
-      this->empty_pages_head = new_page->next_page;
-      // Accept the empty page unless it got decommitted.
-      if (new_page->freelist_head) {
-        new_page->next_page = nullptr;
-        break;
-      }
-      DCHECK(new_page->is_decommitted());
-      new_page->next_page = this->decommitted_pages_head;
-      this->decommitted_pages_head = new_page;
-    }
-    if (UNLIKELY(!new_page) &&
-        LIKELY(this->decommitted_pages_head != nullptr)) {
-      new_page = this->decommitted_pages_head;
-      DCHECK(new_page->bucket == this);
-      DCHECK(new_page->is_decommitted());
-      this->decommitted_pages_head = new_page->next_page;
-      void* addr = PartitionPage::ToPointer(new_page);
-      PartitionRecommitSystemPages(root, addr,
-                                   new_page->bucket->get_bytes_per_span());
-      new_page->Reset();
-    }
-    DCHECK(new_page);
-  } else {
-    // Third. If we get here, we need a brand new page.
-    uint16_t num_partition_pages = this->get_pages_per_slot_span();
-    void* rawPages = AllocNewSlotSpan(root, flags, num_partition_pages);
-    if (LIKELY(rawPages != nullptr)) {
-      new_page = PartitionPage::FromPointerNoAlignmentCheck(rawPages);
-      InitializeSlotSpan(new_page);
-    }
-  }
-
-  // Bail if we had a memory allocation failure.
-  if (UNLIKELY(!new_page)) {
-    DCHECK(this->active_pages_head == &g_sentinel_page);
-    if (returnNull)
-      return nullptr;
-    PartitionOutOfMemory(root);
-  }
-
-  // TODO(ajwong): Is there a way to avoid the reading of bucket here?
-  // It seems like in many of the conditional branches above, |this| ==
-  // |new_page->bucket|. Maybe pull this into another function?
-  PartitionBucket* bucket = new_page->bucket;
-  DCHECK(bucket != get_sentinel_bucket());
-  bucket->active_pages_head = new_page;
-  new_page->set_raw_size(size);
-
-  // If we found an active page with free slots, or an empty page, we have a
-  // usable freelist head.
-  if (LIKELY(new_page->freelist_head != nullptr)) {
-    PartitionFreelistEntry* entry = new_page->freelist_head;
-    PartitionFreelistEntry* new_head =
-        PartitionFreelistEntry::Transform(entry->next);
-    new_page->freelist_head = new_head;
-    new_page->num_allocated_slots++;
-    return entry;
-  }
-  // Otherwise, we need to build the freelist.
-  DCHECK(new_page->num_unprovisioned_slots);
-  return AllocAndFillFreelist(new_page);
-}
-
-PartitionBucket* PartitionBucket::get_sentinel_bucket() {
-  return &g_sentinel_bucket;
-}
-
-static ALWAYS_INLINE void PartitionDecommitPage(PartitionRootBase* root,
-                                                PartitionPage* page) {
-  DCHECK(page->is_empty());
-  DCHECK(!page->bucket->is_direct_mapped());
-  void* addr = PartitionPage::ToPointer(page);
-  PartitionDecommitSystemPages(root, addr, page->bucket->get_bytes_per_span());
-
-  // We actually leave the decommitted page in the active list. We'll sweep
-  // it on to the decommitted page list when we next walk the active page
-  // list.
-  // Pulling this trick enables us to use a singly-linked page list for all
-  // cases, which is critical in keeping the page metadata structure down to
-  // 32 bytes in size.
-  page->freelist_head = nullptr;
-  page->num_unprovisioned_slots = 0;
-  DCHECK(page->is_decommitted());
-}
-
-static void PartitionDecommitPageIfPossible(PartitionRootBase* root,
-                                            PartitionPage* page) {
-  DCHECK(page->empty_cache_index >= 0);
-  DCHECK(static_cast<unsigned>(page->empty_cache_index) < kMaxFreeableSpans);
-  DCHECK(page == root->global_empty_page_ring[page->empty_cache_index]);
-  page->empty_cache_index = -1;
-  if (page->is_empty())
-    PartitionDecommitPage(root, page);
-}
-
-static ALWAYS_INLINE void PartitionRegisterEmptyPage(PartitionPage* page) {
-  DCHECK(page->is_empty());
-  PartitionRootBase* root = PartitionRootBase::FromPage(page);
-
-  // If the page is already registered as empty, give it another life.
-  if (page->empty_cache_index != -1) {
-    DCHECK(page->empty_cache_index >= 0);
-    DCHECK(static_cast<unsigned>(page->empty_cache_index) < kMaxFreeableSpans);
-    DCHECK(root->global_empty_page_ring[page->empty_cache_index] == page);
-    root->global_empty_page_ring[page->empty_cache_index] = nullptr;
-  }
-
-  int16_t current_index = root->global_empty_page_ring_index;
-  PartitionPage* pageToDecommit = root->global_empty_page_ring[current_index];
-  // The page might well have been re-activated, filled up, etc. before we get
-  // around to looking at it here.
-  if (pageToDecommit)
-    PartitionDecommitPageIfPossible(root, pageToDecommit);
-
-  // We put the empty slot span on our global list of "pages that were once
-  // empty". thus providing it a bit of breathing room to get re-used before
-  // we really free it. This improves performance, particularly on Mac OS X
-  // which has subpar memory management performance.
-  root->global_empty_page_ring[current_index] = page;
-  page->empty_cache_index = current_index;
-  ++current_index;
-  if (current_index == kMaxFreeableSpans)
-    current_index = 0;
-  root->global_empty_page_ring_index = current_index;
-}
-
-static void PartitionDecommitEmptyPages(PartitionRootBase* root) {
-  for (size_t i = 0; i < kMaxFreeableSpans; ++i) {
-    PartitionPage* page = root->global_empty_page_ring[i];
-    if (page)
-      PartitionDecommitPageIfPossible(root, page);
-    root->global_empty_page_ring[i] = nullptr;
-  }
-}
-
-PartitionPage* PartitionPage::get_sentinel_page() {
-  return &g_sentinel_page;
-}
-
-void PartitionPage::FreeSlowPath() {
-  DCHECK(this != &g_sentinel_page);
-  if (LIKELY(this->num_allocated_slots == 0)) {
-    // Page became fully unused.
-    if (UNLIKELY(bucket->is_direct_mapped())) {
-      PartitionDirectUnmap(this);
-      return;
-    }
-    // If it's the current active page, change it. We bounce the page to
-    // the empty list as a force towards defragmentation.
-    if (LIKELY(this == bucket->active_pages_head))
-      bucket->SetNewActivePage();
-    DCHECK(bucket->active_pages_head != this);
-
-    set_raw_size(0);
-    DCHECK(!get_raw_size());
-
-    PartitionRegisterEmptyPage(this);
-  } else {
-    DCHECK(!bucket->is_direct_mapped());
-    // Ensure that the page is full. That's the only valid case if we
-    // arrive here.
-    DCHECK(this->num_allocated_slots < 0);
-    // A transition of num_allocated_slots from 0 to -1 is not legal, and
-    // likely indicates a double-free.
-    CHECK(this->num_allocated_slots != -1);
-    this->num_allocated_slots = -this->num_allocated_slots - 2;
-    DCHECK(this->num_allocated_slots == bucket->get_slots_per_span() - 1);
-    // Fully used page became partially used. It must be put back on the
-    // non-full page list. Also make it the current page to increase the
-    // chances of it being filled up again. The old current page will be
-    // the next page.
-    DCHECK(!this->next_page);
-    if (LIKELY(bucket->active_pages_head != &g_sentinel_page))
-      this->next_page = bucket->active_pages_head;
-    bucket->active_pages_head = this;
-    --bucket->num_full_pages;
-    // Special case: for a partition page with just a single slot, it may
-    // now be empty and we want to run it through the empty logic.
-    if (UNLIKELY(this->num_allocated_slots == 0))
-      FreeSlowPath();
-  }
+  *bucketPtr = internal::PartitionBucket::get_sentinel_bucket();
 }
 
 bool PartitionReallocDirectMappedInPlace(PartitionRootGeneric* root,
-                                         PartitionPage* page,
+                                         internal::PartitionPage* page,
                                          size_t raw_size) {
   DCHECK(page->bucket->is_direct_mapped());
 
-  raw_size = PartitionCookieSizeAdjustAdd(raw_size);
+  raw_size = internal::PartitionCookieSizeAdjustAdd(raw_size);
 
   // Note that the new size might be a bucketed size; this function is called
   // whenever we're reallocating a direct mapped allocation.
-  size_t new_size = PartitionDirectMapSize(raw_size);
+  size_t new_size = internal::PartitionBucket::get_direct_map_size(raw_size);
   if (new_size < kGenericMinDirectMappedDownsize)
     return false;
 
@@ -1011,10 +209,11 @@
   if (new_size == current_size)
     return true;
 
-  char* char_ptr = static_cast<char*>(PartitionPage::ToPointer(page));
+  char* char_ptr = static_cast<char*>(internal::PartitionPage::ToPointer(page));
 
   if (new_size < current_size) {
-    size_t map_size = PartitionDirectMapExtent::FromPage(page)->map_size;
+    size_t map_size =
+        internal::PartitionDirectMapExtent::FromPage(page)->map_size;
 
     // Don't reallocate in-place if new size is less than 80 % of the full
     // map size, to avoid holding on to too much unused address space.
@@ -1023,19 +222,21 @@
 
     // Shrink by decommitting unneeded pages and making them inaccessible.
     size_t decommitSize = current_size - new_size;
-    PartitionDecommitSystemPages(root, char_ptr + new_size, decommitSize);
+    root->DecommitSystemPages(char_ptr + new_size, decommitSize);
     CHECK(SetSystemPagesAccess(char_ptr + new_size, decommitSize,
                                PageInaccessible));
-  } else if (new_size <= PartitionDirectMapExtent::FromPage(page)->map_size) {
+  } else if (new_size <=
+             internal::PartitionDirectMapExtent::FromPage(page)->map_size) {
     // Grow within the actually allocated memory. Just need to make the
     // pages accessible again.
     size_t recommit_size = new_size - current_size;
     CHECK(SetSystemPagesAccess(char_ptr + current_size, recommit_size,
                                PageReadWrite));
-    PartitionRecommitSystemPages(root, char_ptr + current_size, recommit_size);
+    root->RecommitSystemPages(char_ptr + current_size, recommit_size);
 
 #if DCHECK_IS_ON()
-    memset(char_ptr + current_size, kUninitializedByte, recommit_size);
+    memset(char_ptr + current_size, internal::kUninitializedByte,
+           recommit_size);
 #endif
   } else {
     // We can't perform the realloc in-place.
@@ -1045,7 +246,8 @@
 
 #if DCHECK_IS_ON()
   // Write a new trailing cookie.
-  PartitionCookieWriteValue(char_ptr + raw_size - kCookieSize);
+  internal::PartitionCookieWriteValue(char_ptr + raw_size -
+                                      internal::kCookieSize);
 #endif
 
   page->set_raw_size(raw_size);
@@ -1069,12 +271,12 @@
   }
 
   if (new_size > kGenericMaxDirectMapped)
-    PartitionExcessiveAllocationSize();
+    internal::PartitionExcessiveAllocationSize();
 
-  PartitionPage* page =
-      PartitionPage::FromPointer(PartitionCookieFreePointerAdjust(ptr));
+  internal::PartitionPage* page = internal::PartitionPage::FromPointer(
+      internal::PartitionCookieFreePointerAdjust(ptr));
   // TODO(palmer): See if we can afford to make this a CHECK.
-  DCHECK(PartitionPage::IsPointerValid(page));
+  DCHECK(internal::PartitionPage::IsPointerValid(page));
 
   if (UNLIKELY(page->bucket->is_direct_mapped())) {
     // We may be able to perform the realloc in place by changing the
@@ -1096,12 +298,12 @@
     // Trying to allocate a block of size new_size would give us a block of
     // the same size as the one we've already got, so re-use the allocation
     // after updating statistics (and cookies, if present).
-    page->set_raw_size(PartitionCookieSizeAdjustAdd(new_size));
+    page->set_raw_size(internal::PartitionCookieSizeAdjustAdd(new_size));
 #if DCHECK_IS_ON()
     // Write a new trailing cookie when it is possible to keep track of
     // |new_size| via the raw size pointer.
     if (page->get_raw_size_ptr())
-      PartitionCookieWriteValue(static_cast<char*>(ptr) + new_size);
+      internal::PartitionCookieWriteValue(static_cast<char*>(ptr) + new_size);
 #endif
     return ptr;
   }
@@ -1118,8 +320,8 @@
 #endif
 }
 
-static size_t PartitionPurgePage(PartitionPage* page, bool discard) {
-  const PartitionBucket* bucket = page->bucket;
+static size_t PartitionPurgePage(internal::PartitionPage* page, bool discard) {
+  const internal::PartitionBucket* bucket = page->bucket;
   size_t slot_size = bucket->slot_size;
   if (slot_size < kSystemPageSize || !page->num_allocated_slots)
     return 0;
@@ -1132,7 +334,8 @@
     uint32_t usedBytes = static_cast<uint32_t>(RoundUpToSystemPage(raw_size));
     discardable_bytes = bucket->slot_size - usedBytes;
     if (discardable_bytes && discard) {
-      char* ptr = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
+      char* ptr =
+          reinterpret_cast<char*>(internal::PartitionPage::ToPointer(page));
       ptr += usedBytes;
       DiscardSystemPages(ptr, discardable_bytes);
     }
@@ -1151,21 +354,22 @@
   size_t last_slot = static_cast<size_t>(-1);
 #endif
   memset(slot_usage, 1, num_slots);
-  char* ptr = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
+  char* ptr = reinterpret_cast<char*>(internal::PartitionPage::ToPointer(page));
   // First, walk the freelist for this page and make a bitmap of which slots
   // are not in use.
-  for (PartitionFreelistEntry* entry = page->freelist_head; entry; /**/) {
+  for (internal::PartitionFreelistEntry* entry = page->freelist_head; entry;
+       /**/) {
     size_t slotIndex = (reinterpret_cast<char*>(entry) - ptr) / slot_size;
     DCHECK(slotIndex < num_slots);
     slot_usage[slotIndex] = 0;
-    entry = PartitionFreelistEntry::Transform(entry->next);
+    entry = internal::PartitionFreelistEntry::Transform(entry->next);
 #if !defined(OS_WIN)
     // If we have a slot where the masked freelist entry is 0, we can
     // actually discard that freelist entry because touching a discarded
     // page is guaranteed to return original content or 0.
     // (Note that this optimization won't fire on big endian machines
     // because the masking function is negation.)
-    if (!PartitionFreelistEntry::Transform(entry))
+    if (!internal::PartitionFreelistEntry::Transform(entry))
       last_slot = slotIndex;
 #endif
   }
@@ -1200,14 +404,14 @@
       size_t num_new_entries = 0;
       page->num_unprovisioned_slots += static_cast<uint16_t>(truncated_slots);
       // Rewrite the freelist.
-      PartitionFreelistEntry** entry_ptr = &page->freelist_head;
+      internal::PartitionFreelistEntry** entry_ptr = &page->freelist_head;
       for (size_t slotIndex = 0; slotIndex < num_slots; ++slotIndex) {
         if (slot_usage[slotIndex])
           continue;
-        auto* entry = reinterpret_cast<PartitionFreelistEntry*>(
+        auto* entry = reinterpret_cast<internal::PartitionFreelistEntry*>(
             ptr + (slot_size * slotIndex));
-        *entry_ptr = PartitionFreelistEntry::Transform(entry);
-        entry_ptr = reinterpret_cast<PartitionFreelistEntry**>(entry);
+        *entry_ptr = internal::PartitionFreelistEntry::Transform(entry);
+        entry_ptr = reinterpret_cast<internal::PartitionFreelistEntry**>(entry);
         num_new_entries++;
 #if !defined(OS_WIN)
         last_slot = slotIndex;
@@ -1217,7 +421,7 @@
       *entry_ptr = nullptr;
       // The freelist head is stored unmasked.
       page->freelist_head =
-          PartitionFreelistEntry::Transform(page->freelist_head);
+          internal::PartitionFreelistEntry::Transform(page->freelist_head);
       DCHECK(num_new_entries == num_slots - page->num_allocated_slots);
       // Discard the memory.
       DiscardSystemPages(begin_ptr, unprovisioned_bytes);
@@ -1238,9 +442,9 @@
     char* end_ptr = begin_ptr + slot_size;
 #if !defined(OS_WIN)
     if (i != last_slot)
-      begin_ptr += sizeof(PartitionFreelistEntry);
+      begin_ptr += sizeof(internal::PartitionFreelistEntry);
 #else
-    begin_ptr += sizeof(PartitionFreelistEntry);
+    begin_ptr += sizeof(internal::PartitionFreelistEntry);
 #endif
     begin_ptr = reinterpret_cast<char*>(
         RoundUpToSystemPage(reinterpret_cast<size_t>(begin_ptr)));
@@ -1256,11 +460,12 @@
   return discardable_bytes;
 }
 
-static void PartitionPurgeBucket(PartitionBucket* bucket) {
-  if (bucket->active_pages_head != &g_sentinel_page) {
-    for (PartitionPage* page = bucket->active_pages_head; page;
+static void PartitionPurgeBucket(internal::PartitionBucket* bucket) {
+  if (bucket->active_pages_head !=
+      internal::PartitionPage::get_sentinel_page()) {
+    for (internal::PartitionPage* page = bucket->active_pages_head; page;
          page = page->next_page) {
-      DCHECK(page != &g_sentinel_page);
+      DCHECK(page != internal::PartitionPage::get_sentinel_page());
       PartitionPurgePage(page, true);
     }
   }
@@ -1268,7 +473,7 @@
 
 void PartitionRoot::PurgeMemory(int flags) {
   if (flags & PartitionPurgeDecommitEmptyPages)
-    PartitionDecommitEmptyPages(this);
+    DecommitEmptyPages();
   // We don't currently do anything for PartitionPurgeDiscardUnusedSystemPages
   // here because that flag is only useful for allocations >= system page
   // size. We only have allocations that large inside generic partitions
@@ -1278,10 +483,10 @@
 void PartitionRootGeneric::PurgeMemory(int flags) {
   subtle::SpinLock::Guard guard(this->lock);
   if (flags & PartitionPurgeDecommitEmptyPages)
-    PartitionDecommitEmptyPages(this);
+    DecommitEmptyPages();
   if (flags & PartitionPurgeDiscardUnusedSystemPages) {
     for (size_t i = 0; i < kGenericNumBuckets; ++i) {
-      PartitionBucket* bucket = &this->buckets[i];
+      internal::PartitionBucket* bucket = &this->buckets[i];
       if (bucket->slot_size >= kSystemPageSize)
         PartitionPurgeBucket(bucket);
     }
@@ -1289,7 +494,7 @@
 }
 
 static void PartitionDumpPageStats(PartitionBucketMemoryStats* stats_out,
-                                   PartitionPage* page) {
+                                   internal::PartitionPage* page) {
   uint16_t bucket_num_slots = page->bucket->get_slots_per_span();
 
   if (page->is_decommitted()) {
@@ -1323,13 +528,15 @@
 }
 
 static void PartitionDumpBucketStats(PartitionBucketMemoryStats* stats_out,
-                                     const PartitionBucket* bucket) {
+                                     const internal::PartitionBucket* bucket) {
   DCHECK(!bucket->is_direct_mapped());
   stats_out->is_valid = false;
-  // If the active page list is empty (== &g_sentinel_page),
+  // If the active page list is empty (==
+  // internal::PartitionPage::get_sentinel_page()),
   // the bucket might still need to be reported if it has a list of empty,
   // decommitted or full pages.
-  if (bucket->active_pages_head == &g_sentinel_page &&
+  if (bucket->active_pages_head ==
+          internal::PartitionPage::get_sentinel_page() &&
       !bucket->empty_pages_head && !bucket->decommitted_pages_head &&
       !bucket->num_full_pages)
     return;
@@ -1346,21 +553,22 @@
   stats_out->resident_bytes =
       bucket->num_full_pages * stats_out->allocated_page_size;
 
-  for (PartitionPage* page = bucket->empty_pages_head; page;
+  for (internal::PartitionPage* page = bucket->empty_pages_head; page;
        page = page->next_page) {
     DCHECK(page->is_empty() || page->is_decommitted());
     PartitionDumpPageStats(stats_out, page);
   }
-  for (PartitionPage* page = bucket->decommitted_pages_head; page;
+  for (internal::PartitionPage* page = bucket->decommitted_pages_head; page;
        page = page->next_page) {
     DCHECK(page->is_decommitted());
     PartitionDumpPageStats(stats_out, page);
   }
 
-  if (bucket->active_pages_head != &g_sentinel_page) {
-    for (PartitionPage* page = bucket->active_pages_head; page;
+  if (bucket->active_pages_head !=
+      internal::PartitionPage::get_sentinel_page()) {
+    for (internal::PartitionPage* page = bucket->active_pages_head; page;
          page = page->next_page) {
-      DCHECK(page != &g_sentinel_page);
+      DCHECK(page != internal::PartitionPage::get_sentinel_page());
       PartitionDumpPageStats(stats_out, page);
     }
   }
@@ -1392,7 +600,7 @@
     subtle::SpinLock::Guard guard(this->lock);
 
     for (size_t i = 0; i < kGenericNumBuckets; ++i) {
-      const PartitionBucket* bucket = &this->buckets[i];
+      const internal::PartitionBucket* bucket = &this->buckets[i];
       // Don't report the pseudo buckets that the generic allocator sets up in
       // order to preserve a fast size->bucket map (see
       // PartitionRootGeneric::Init() for details).
@@ -1408,7 +616,7 @@
       }
     }
 
-    for (PartitionDirectMapExtent *extent = this->direct_map_list;
+    for (internal::PartitionDirectMapExtent *extent = this->direct_map_list;
          extent && num_direct_mapped_allocations < kMaxReportableDirectMaps;
          extent = extent->next_extent, ++num_direct_mapped_allocations) {
       DCHECK(!extent->next_extent ||
diff --git a/base/allocator/partition_allocator/partition_alloc.h b/base/allocator/partition_allocator/partition_alloc.h
index f4a4f0a..35f9280 100644
--- a/base/allocator/partition_allocator/partition_alloc.h
+++ b/base/allocator/partition_allocator/partition_alloc.h
@@ -64,6 +64,11 @@
 #include <string.h>
 
 #include "base/allocator/partition_allocator/page_allocator.h"
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+#include "base/allocator/partition_allocator/partition_bucket-inl.h"
+#include "base/allocator/partition_allocator/partition_cookie.h"
+#include "base/allocator/partition_allocator/partition_page-inl.h"
+#include "base/allocator/partition_allocator/partition_root_base-inl.h"
 #include "base/allocator/partition_allocator/spin_lock.h"
 #include "base/base_export.h"
 #include "base/bits.h"
@@ -79,411 +84,7 @@
 
 namespace base {
 
-// Allocation granularity of sizeof(void*) bytes.
-static const size_t kAllocationGranularity = sizeof(void*);
-static const size_t kAllocationGranularityMask = kAllocationGranularity - 1;
-static const size_t kBucketShift = (kAllocationGranularity == 8) ? 3 : 2;
-
-// Underlying partition storage pages are a power-of-two size. It is typical
-// for a partition page to be based on multiple system pages. Most references to
-// "page" refer to partition pages.
-// We also have the concept of "super pages" -- these are the underlying system
-// allocations we make. Super pages contain multiple partition pages inside them
-// and include space for a small amount of metadata per partition page.
-// Inside super pages, we store "slot spans". A slot span is a continguous range
-// of one or more partition pages that stores allocations of the same size.
-// Slot span sizes are adjusted depending on the allocation size, to make sure
-// the packing does not lead to unused (wasted) space at the end of the last
-// system page of the span. For our current max slot span size of 64k and other
-// constant values, we pack _all_ PartitionRootGeneric::Alloc() sizes perfectly
-// up against the end of a system page.
-#if defined(_MIPS_ARCH_LOONGSON)
-static const size_t kPartitionPageShift = 16;  // 64KB
-#else
-static const size_t kPartitionPageShift = 14;  // 16KB
-#endif
-static const size_t kPartitionPageSize = 1 << kPartitionPageShift;
-static const size_t kPartitionPageOffsetMask = kPartitionPageSize - 1;
-static const size_t kPartitionPageBaseMask = ~kPartitionPageOffsetMask;
-static const size_t kMaxPartitionPagesPerSlotSpan = 4;
-
-// To avoid fragmentation via never-used freelist entries, we hand out partition
-// freelist sections gradually, in units of the dominant system page size.
-// What we're actually doing is avoiding filling the full partition page (16 KB)
-// with freelist pointers right away. Writing freelist pointers will fault and
-// dirty a private page, which is very wasteful if we never actually store
-// objects there.
-static const size_t kNumSystemPagesPerPartitionPage =
-    kPartitionPageSize / kSystemPageSize;
-static const size_t kMaxSystemPagesPerSlotSpan =
-    kNumSystemPagesPerPartitionPage * kMaxPartitionPagesPerSlotSpan;
-
-// We reserve virtual address space in 2MB chunks (aligned to 2MB as well).
-// These chunks are called "super pages". We do this so that we can store
-// metadata in the first few pages of each 2MB aligned section. This leads to
-// a very fast free(). We specifically choose 2MB because this virtual address
-// block represents a full but single PTE allocation on ARM, ia32 and x64.
-//
-// The layout of the super page is as follows. The sizes below are the same
-// for 32 bit and 64 bit.
-//
-//   | Guard page (4KB)    |
-//   | Metadata page (4KB) |
-//   | Guard pages (8KB)   |
-//   | Slot span           |
-//   | Slot span           |
-//   | ...                 |
-//   | Slot span           |
-//   | Guard page (4KB)    |
-//
-//   - Each slot span is a contiguous range of one or more PartitionPages.
-//   - The metadata page has the following format. Note that the PartitionPage
-//     that is not at the head of a slot span is "unused". In other words,
-//     the metadata for the slot span is stored only in the first PartitionPage
-//     of the slot span. Metadata accesses to other PartitionPages are
-//     redirected to the first PartitionPage.
-//
-//     | SuperPageExtentEntry (32B)                 |
-//     | PartitionPage of slot span 1 (32B, used)   |
-//     | PartitionPage of slot span 1 (32B, unused) |
-//     | PartitionPage of slot span 1 (32B, unused) |
-//     | PartitionPage of slot span 2 (32B, used)   |
-//     | PartitionPage of slot span 3 (32B, used)   |
-//     | ...                                        |
-//     | PartitionPage of slot span N (32B, unused) |
-//
-// A direct mapped page has a similar layout to fake it looking like a super
-// page:
-//
-//     | Guard page (4KB)     |
-//     | Metadata page (4KB)  |
-//     | Guard pages (8KB)    |
-//     | Direct mapped object |
-//     | Guard page (4KB)     |
-//
-//    - The metadata page has the following layout:
-//
-//     | SuperPageExtentEntry (32B)    |
-//     | PartitionPage (32B)           |
-//     | PartitionBucket (32B)         |
-//     | PartitionDirectMapExtent (8B) |
-static const size_t kSuperPageShift = 21;  // 2MB
-static const size_t kSuperPageSize = 1 << kSuperPageShift;
-static const size_t kSuperPageOffsetMask = kSuperPageSize - 1;
-static const size_t kSuperPageBaseMask = ~kSuperPageOffsetMask;
-static const size_t kNumPartitionPagesPerSuperPage =
-    kSuperPageSize / kPartitionPageSize;
-
-static const size_t kPageMetadataShift = 5;  // 32 bytes per partition page.
-static const size_t kPageMetadataSize = 1 << kPageMetadataShift;
-
-// The following kGeneric* constants apply to the generic variants of the API.
-// The "order" of an allocation is closely related to the power-of-two size of
-// the allocation. More precisely, the order is the bit index of the
-// most-significant-bit in the allocation size, where the bit numbers starts
-// at index 1 for the least-significant-bit.
-// In terms of allocation sizes, order 0 covers 0, order 1 covers 1, order 2
-// covers 2->3, order 3 covers 4->7, order 4 covers 8->15.
-static const size_t kGenericMinBucketedOrder = 4;  // 8 bytes.
-static const size_t kGenericMaxBucketedOrder =
-    20;  // Largest bucketed order is 1<<(20-1) (storing 512KB -> almost 1MB)
-static const size_t kGenericNumBucketedOrders =
-    (kGenericMaxBucketedOrder - kGenericMinBucketedOrder) + 1;
-// Eight buckets per order (for the higher orders), e.g. order 8 is 128, 144,
-// 160, ..., 240:
-static const size_t kGenericNumBucketsPerOrderBits = 3;
-static const size_t kGenericNumBucketsPerOrder =
-    1 << kGenericNumBucketsPerOrderBits;
-static const size_t kGenericNumBuckets =
-    kGenericNumBucketedOrders * kGenericNumBucketsPerOrder;
-static const size_t kGenericSmallestBucket = 1
-                                             << (kGenericMinBucketedOrder - 1);
-static const size_t kGenericMaxBucketSpacing =
-    1 << ((kGenericMaxBucketedOrder - 1) - kGenericNumBucketsPerOrderBits);
-static const size_t kGenericMaxBucketed =
-    (1 << (kGenericMaxBucketedOrder - 1)) +
-    ((kGenericNumBucketsPerOrder - 1) * kGenericMaxBucketSpacing);
-static const size_t kGenericMinDirectMappedDownsize =
-    kGenericMaxBucketed +
-    1;  // Limit when downsizing a direct mapping using realloc().
-static const size_t kGenericMaxDirectMapped =
-    (1UL << 31) + kPageAllocationGranularity;  // 2 GiB plus one more page.
-static const size_t kBitsPerSizeT = sizeof(void*) * CHAR_BIT;
-
-// Constants for the memory reclaim logic.
-static const size_t kMaxFreeableSpans = 16;
-
-// If the total size in bytes of allocated but not committed pages exceeds this
-// value (probably it is a "out of virtual address space" crash),
-// a special crash stack trace is generated at |partitionOutOfMemory|.
-// This is to distinguish "out of virtual address space" from
-// "out of physical memory" in crash reports.
-static const size_t kReasonableSizeOfUnusedPages = 1024 * 1024 * 1024;  // 1GiB
-
-#if DCHECK_IS_ON()
-// These two byte values match tcmalloc.
-static const unsigned char kUninitializedByte = 0xAB;
-static const unsigned char kFreedByte = 0xCD;
-static const size_t kCookieSize =
-    16;  // Handles alignment up to XMM instructions on Intel.
-static const unsigned char kCookieValue[kCookieSize] = {
-    0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xD0, 0x0D,
-    0x13, 0x37, 0xF0, 0x05, 0xBA, 0x11, 0xAB, 0x1E};
-#endif
-
 class PartitionStatsDumper;
-struct PartitionBucket;
-struct PartitionRootBase;
-
-// TODO(ajwong): Introduce an EncodedFreelistEntry type and then replace
-// Transform() with Encode()/Decode() such that the API provides some static
-// type safety.
-//
-// https://crbug.com/787153
-struct PartitionFreelistEntry {
-  PartitionFreelistEntry* next;
-
-  static ALWAYS_INLINE PartitionFreelistEntry* Transform(
-      PartitionFreelistEntry* ptr) {
-// We use bswap on little endian as a fast mask for two reasons:
-// 1) If an object is freed and its vtable used where the attacker doesn't
-// get the chance to run allocations between the free and use, the vtable
-// dereference is likely to fault.
-// 2) If the attacker has a linear buffer overflow and elects to try and
-// corrupt a freelist pointer, partial pointer overwrite attacks are
-// thwarted.
-// For big endian, similar guarantees are arrived at with a negation.
-#if defined(ARCH_CPU_BIG_ENDIAN)
-    uintptr_t masked = ~reinterpret_cast<uintptr_t>(ptr);
-#else
-    uintptr_t masked = ByteSwapUintPtrT(reinterpret_cast<uintptr_t>(ptr));
-#endif
-    return reinterpret_cast<PartitionFreelistEntry*>(masked);
-  }
-};
-
-// Some notes on page states. A page can be in one of four major states:
-// 1) Active.
-// 2) Full.
-// 3) Empty.
-// 4) Decommitted.
-// An active page has available free slots. A full page has no free slots. An
-// empty page has no free slots, and a decommitted page is an empty page that
-// had its backing memory released back to the system.
-// There are two linked lists tracking the pages. The "active page" list is an
-// approximation of a list of active pages. It is an approximation because
-// full, empty and decommitted pages may briefly be present in the list until
-// we next do a scan over it.
-// The "empty page" list is an accurate list of pages which are either empty
-// or decommitted.
-//
-// The significant page transitions are:
-// - free() will detect when a full page has a slot free()'d and immediately
-// return the page to the head of the active list.
-// - free() will detect when a page is fully emptied. It _may_ add it to the
-// empty list or it _may_ leave it on the active list until a future list scan.
-// - malloc() _may_ scan the active page list in order to fulfil the request.
-// If it does this, full, empty and decommitted pages encountered will be
-// booted out of the active list. If there are no suitable active pages found,
-// an empty or decommitted page (if one exists) will be pulled from the empty
-// list on to the active list.
-//
-// TODO(ajwong): Evaluate if this should be named PartitionSlotSpanMetadata or
-// similar. If so, all uses of the term "page" in comments, member variables,
-// local variables, and documentation that refer to this concept should be
-// updated.
-struct PartitionPage {
-  PartitionFreelistEntry* freelist_head;
-  PartitionPage* next_page;
-  PartitionBucket* bucket;
-  // Deliberately signed, 0 for empty or decommitted page, -n for full pages:
-  int16_t num_allocated_slots;
-  uint16_t num_unprovisioned_slots;
-  uint16_t page_offset;
-  int16_t empty_cache_index;  // -1 if not in the empty cache.
-
-  // Public API
-
-  // Note the matching Alloc() functions are in PartitionPage.
-  BASE_EXPORT NOINLINE void FreeSlowPath();
-  ALWAYS_INLINE void Free(void* ptr);
-
-  // Pointer manipulation functions. These must be static as the input |page|
-  // pointer may be the result of an offset calculation and therefore cannot
-  // be trusted. The objective of these functions is to sanitize this input.
-  ALWAYS_INLINE static void* ToPointer(const PartitionPage* page);
-  ALWAYS_INLINE static PartitionPage* FromPointerNoAlignmentCheck(void* ptr);
-  ALWAYS_INLINE static PartitionPage* FromPointer(void* ptr);
-  ALWAYS_INLINE static bool IsPointerValid(PartitionPage* page);
-
-  ALWAYS_INLINE const size_t* get_raw_size_ptr() const;
-  ALWAYS_INLINE size_t* get_raw_size_ptr() {
-    return const_cast<size_t*>(
-        const_cast<const PartitionPage*>(this)->get_raw_size_ptr());
-  }
-
-  ALWAYS_INLINE size_t get_raw_size() const;
-  ALWAYS_INLINE void set_raw_size(size_t size);
-
-  ALWAYS_INLINE void Reset();
-
-  // TODO(ajwong): Can this be made private?  https://crbug.com/787153
-  BASE_EXPORT static PartitionPage* get_sentinel_page();
-
-  // Page State accessors.
-  // Note that it's only valid to call these functions on pages found on one of
-  // the page lists. Specifically, you can't call these functions on full pages
-  // that were detached from the active list.
-  //
-  // This restriction provides the flexibity for some of the status fields to
-  // be repurposed when a page is taken off a list. See the negation of
-  // |num_allocated_slots| when a full page is removed from the active list
-  // for an example of such repurposing.
-  ALWAYS_INLINE bool is_active() const;
-  ALWAYS_INLINE bool is_full() const;
-  ALWAYS_INLINE bool is_empty() const;
-  ALWAYS_INLINE bool is_decommitted() const;
-};
-static_assert(sizeof(PartitionPage) <= kPageMetadataSize,
-              "PartitionPage must be able to fit in a metadata slot");
-
-struct PartitionBucket {
-  // Accessed most in hot path => goes first.
-  PartitionPage* active_pages_head;
-
-  PartitionPage* empty_pages_head;
-  PartitionPage* decommitted_pages_head;
-  uint32_t slot_size;
-  unsigned num_system_pages_per_slot_span : 8;
-  unsigned num_full_pages : 24;
-
-  // Public API.
-  void Init(uint32_t new_slot_size);
-
-  // Note the matching Free() functions are in PartitionPage.
-  BASE_EXPORT void* Alloc(PartitionRootBase* root, int flags, size_t size);
-  BASE_EXPORT NOINLINE void* SlowPathAlloc(PartitionRootBase* root,
-                                           int flags,
-                                           size_t size);
-
-  ALWAYS_INLINE bool is_direct_mapped() const {
-    return !num_system_pages_per_slot_span;
-  }
-  ALWAYS_INLINE size_t get_bytes_per_span() const {
-    // TODO(ajwong): Chagne to CheckedMul. https://crbug.com/787153
-    return num_system_pages_per_slot_span * kSystemPageSize;
-  }
-  ALWAYS_INLINE uint16_t get_slots_per_span() const {
-    // TODO(ajwong): Chagne to CheckedMul. https://crbug.com/787153
-    return static_cast<uint16_t>(get_bytes_per_span() / slot_size);
-  }
-
-  // TODO(ajwong): Can this be made private?  https://crbug.com/787153
-  static PartitionBucket* get_sentinel_bucket();
-
-  // This helper function scans a bucket's active page list for a suitable new
-  // active page.  When it finds a suitable new active page (one that has
-  // free slots and is not empty), it is set as the new active page. If there
-  // is no suitable new active page, the current active page is set to
-  // PartitionPage::get_sentinel_page(). As potential pages are scanned, they
-  // are tidied up according to their state. Empty pages are swept on to the
-  // empty page list, decommitted pages on to the decommitted page list and full
-  // pages are unlinked from any list.
-  //
-  // This is where the guts of the bucket maintenance is done!
-  bool SetNewActivePage();
-
- private:
-  static void OutOfMemory(const PartitionRootBase* root);
-  static void OutOfMemoryWithLotsOfUncommitedPages();
-
-  static NOINLINE void OnFull();
-
-  // Returns a natural number of PartitionPages (calculated by
-  // get_system_pages_per_slot_span()) to allocate from the current
-  // SuperPage when the bucket runs out of slots.
-  ALWAYS_INLINE uint16_t get_pages_per_slot_span();
-
-  // Returns the number of system pages in a slot span.
-  //
-  // The calculation attemps to find the best number of System Pages to
-  // allocate for the given slot_size to minimize wasted space. It uses a
-  // heuristic that looks at number of bytes wasted after the last slot and
-  // attempts to account for the PTE usage of each System Page.
-  uint8_t get_system_pages_per_slot_span();
-
-  // Allocates a new slot span with size |num_partition_pages| from the
-  // current extent. Metadata within this slot span will be uninitialized.
-  // Returns nullptr on error.
-  ALWAYS_INLINE void* AllocNewSlotSpan(PartitionRootBase* root,
-                                       int flags,
-                                       uint16_t num_partition_pages);
-
-  // Each bucket allocates a slot span when it runs out of slots.
-  // A slot span's size is equal to get_pages_per_slot_span() number of
-  // PartitionPages. This function initializes all PartitionPage within the
-  // span to point to the first PartitionPage which holds all the metadata
-  // for the span and registers this bucket as the owner of the span. It does
-  // NOT put the slots into the bucket's freelist.
-  ALWAYS_INLINE void InitializeSlotSpan(PartitionPage* page);
-
-  // Allocates one slot from the given |page| and then adds the remainder to
-  // the current bucket. If the |page| was freshly allocated, it must have been
-  // passed through InitializeSlotSpan() first.
-  ALWAYS_INLINE char* AllocAndFillFreelist(PartitionPage* page);
-};
-
-// An "extent" is a span of consecutive superpages. We link to the partition's
-// next extent (if there is one) to the very start of a superpage's metadata
-// area.
-struct PartitionSuperPageExtentEntry {
-  PartitionRootBase* root;
-  char* super_page_base;
-  char* super_pages_end;
-  PartitionSuperPageExtentEntry* next;
-};
-static_assert(
-    sizeof(PartitionSuperPageExtentEntry) <= kPageMetadataSize,
-    "PartitionSuperPageExtentEntry must be able to fit in a metadata slot");
-
-struct PartitionDirectMapExtent {
-  PartitionDirectMapExtent* next_extent;
-  PartitionDirectMapExtent* prev_extent;
-  PartitionBucket* bucket;
-  size_t map_size;  // Mapped size, not including guard pages and meta-data.
-
-  ALWAYS_INLINE static PartitionDirectMapExtent* FromPage(PartitionPage* page);
-};
-
-struct BASE_EXPORT PartitionRootBase {
-  PartitionRootBase();
-  virtual ~PartitionRootBase();
-  size_t total_size_of_committed_pages = 0;
-  size_t total_size_of_super_pages = 0;
-  size_t total_size_of_direct_mapped_pages = 0;
-  // Invariant: total_size_of_committed_pages <=
-  //                total_size_of_super_pages +
-  //                total_size_of_direct_mapped_pages.
-  unsigned num_buckets = 0;
-  unsigned max_allocation = 0;
-  bool initialized = false;
-  char* next_super_page = nullptr;
-  char* next_partition_page = nullptr;
-  char* next_partition_page_end = nullptr;
-  PartitionSuperPageExtentEntry* current_extent = nullptr;
-  PartitionSuperPageExtentEntry* first_extent = nullptr;
-  PartitionDirectMapExtent* direct_map_list = nullptr;
-  PartitionPage* global_empty_page_ring[kMaxFreeableSpans] = {};
-  int16_t global_empty_page_ring_index = 0;
-  uintptr_t inverted_self = 0;
-
-  // Pubic API
-
-  // gOomHandlingFunction is invoked when PartitionAlloc hits OutOfMemory.
-  static void (*gOomHandlingFunction)();
-
-  ALWAYS_INLINE static PartitionRootBase* FromPage(PartitionPage* page);
-};
 
 enum PartitionPurgeFlags {
   // Decommitting the ring list of empty pages is reasonably fast.
@@ -496,18 +97,18 @@
 };
 
 // Never instantiate a PartitionRoot directly, instead use PartitionAlloc.
-struct BASE_EXPORT PartitionRoot : public PartitionRootBase {
+struct BASE_EXPORT PartitionRoot : public internal::PartitionRootBase {
   PartitionRoot();
   ~PartitionRoot() override;
   // This references the buckets OFF the edge of this struct. All uses of
   // PartitionRoot must have the bucket array come right after.
   //
   // The PartitionAlloc templated class ensures the following is correct.
-  ALWAYS_INLINE PartitionBucket* buckets() {
-    return reinterpret_cast<PartitionBucket*>(this + 1);
+  ALWAYS_INLINE internal::PartitionBucket* buckets() {
+    return reinterpret_cast<internal::PartitionBucket*>(this + 1);
   }
-  ALWAYS_INLINE const PartitionBucket* buckets() const {
-    return reinterpret_cast<const PartitionBucket*>(this + 1);
+  ALWAYS_INLINE const internal::PartitionBucket* buckets() const {
+    return reinterpret_cast<const internal::PartitionBucket*>(this + 1);
   }
 
   void Init(size_t num_buckets, size_t max_allocation);
@@ -523,7 +124,7 @@
 
 // Never instantiate a PartitionRootGeneric directly, instead use
 // PartitionAllocatorGeneric.
-struct BASE_EXPORT PartitionRootGeneric : public PartitionRootBase {
+struct BASE_EXPORT PartitionRootGeneric : public internal::PartitionRootBase {
   PartitionRootGeneric();
   ~PartitionRootGeneric() override;
   subtle::SpinLock lock;
@@ -535,10 +136,10 @@
   // sizes.  It is one flat array instead of a 2D array because in the 2D
   // world, we'd need to index array[blah][max+1] which risks undefined
   // behavior.
-  PartitionBucket*
+  internal::PartitionBucket*
       bucket_lookups[((kBitsPerSizeT + 1) * kGenericNumBucketsPerOrder) + 1] =
           {};
-  PartitionBucket buckets[kGenericNumBuckets] = {};
+  internal::PartitionBucket buckets[kGenericNumBuckets] = {};
 
   // Public API.
   void Init();
@@ -557,11 +158,6 @@
                  PartitionStatsDumper* partition_stats_dumper);
 };
 
-// Flags for PartitionAllocGenericFlags.
-enum PartitionAllocFlags {
-  PartitionAllocReturnNull = 1 << 0,
-};
-
 // Struct used to retrieve total memory usage of a partition. Used by
 // PartitionStatsDumper implementation.
 struct PartitionMemoryStats {
@@ -662,198 +258,6 @@
   static FreeHook* free_hook_;
 };
 
-ALWAYS_INLINE size_t PartitionCookieSizeAdjustAdd(size_t size) {
-#if DCHECK_IS_ON()
-  // Add space for cookies, checking for integer overflow. TODO(palmer):
-  // Investigate the performance and code size implications of using
-  // CheckedNumeric throughout PA.
-  DCHECK(size + (2 * kCookieSize) > size);
-  size += 2 * kCookieSize;
-#endif
-  return size;
-}
-
-ALWAYS_INLINE size_t PartitionCookieSizeAdjustSubtract(size_t size) {
-#if DCHECK_IS_ON()
-  // Remove space for cookies.
-  DCHECK(size >= 2 * kCookieSize);
-  size -= 2 * kCookieSize;
-#endif
-  return size;
-}
-
-ALWAYS_INLINE void* PartitionCookieFreePointerAdjust(void* ptr) {
-#if DCHECK_IS_ON()
-  // The value given to the application is actually just after the cookie.
-  ptr = static_cast<char*>(ptr) - kCookieSize;
-#endif
-  return ptr;
-}
-
-ALWAYS_INLINE void PartitionCookieWriteValue(void* ptr) {
-#if DCHECK_IS_ON()
-  unsigned char* cookie_ptr = reinterpret_cast<unsigned char*>(ptr);
-  for (size_t i = 0; i < kCookieSize; ++i, ++cookie_ptr)
-    *cookie_ptr = kCookieValue[i];
-#endif
-}
-
-ALWAYS_INLINE void PartitionCookieCheckValue(void* ptr) {
-#if DCHECK_IS_ON()
-  unsigned char* cookie_ptr = reinterpret_cast<unsigned char*>(ptr);
-  for (size_t i = 0; i < kCookieSize; ++i, ++cookie_ptr)
-    DCHECK(*cookie_ptr == kCookieValue[i]);
-#endif
-}
-
-ALWAYS_INLINE char* PartitionSuperPageToMetadataArea(char* ptr) {
-  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(ptr);
-  DCHECK(!(pointer_as_uint & kSuperPageOffsetMask));
-  // The metadata area is exactly one system page (the guard page) into the
-  // super page.
-  return reinterpret_cast<char*>(pointer_as_uint + kSystemPageSize);
-}
-
-ALWAYS_INLINE PartitionPage* PartitionPage::FromPointerNoAlignmentCheck(
-    void* ptr) {
-  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(ptr);
-  char* super_page_ptr =
-      reinterpret_cast<char*>(pointer_as_uint & kSuperPageBaseMask);
-  uintptr_t partition_page_index =
-      (pointer_as_uint & kSuperPageOffsetMask) >> kPartitionPageShift;
-  // Index 0 is invalid because it is the metadata and guard area and
-  // the last index is invalid because it is a guard page.
-  DCHECK(partition_page_index);
-  DCHECK(partition_page_index < kNumPartitionPagesPerSuperPage - 1);
-  PartitionPage* page = reinterpret_cast<PartitionPage*>(
-      PartitionSuperPageToMetadataArea(super_page_ptr) +
-      (partition_page_index << kPageMetadataShift));
-  // Partition pages in the same slot span can share the same page object.
-  // Adjust for that.
-  size_t delta = page->page_offset << kPageMetadataShift;
-  page =
-      reinterpret_cast<PartitionPage*>(reinterpret_cast<char*>(page) - delta);
-  return page;
-}
-
-// Resturns start of the slot span for the PartitionPage.
-ALWAYS_INLINE void* PartitionPage::ToPointer(const PartitionPage* page) {
-  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(page);
-
-  uintptr_t super_page_offset = (pointer_as_uint & kSuperPageOffsetMask);
-
-  // A valid |page| must be past the first guard System page and within
-  // the following metadata region.
-  DCHECK(super_page_offset > kSystemPageSize);
-  // Must be less than total metadata region.
-  DCHECK(super_page_offset < kSystemPageSize + (kNumPartitionPagesPerSuperPage *
-                                                kPageMetadataSize));
-  uintptr_t partition_page_index =
-      (super_page_offset - kSystemPageSize) >> kPageMetadataShift;
-  // Index 0 is invalid because it is the superpage extent metadata and the
-  // last index is invalid because the whole PartitionPage is set as guard
-  // pages for the metadata region.
-  DCHECK(partition_page_index);
-  DCHECK(partition_page_index < kNumPartitionPagesPerSuperPage - 1);
-  uintptr_t super_page_base = (pointer_as_uint & kSuperPageBaseMask);
-  void* ret = reinterpret_cast<void*>(
-      super_page_base + (partition_page_index << kPartitionPageShift));
-  return ret;
-}
-
-ALWAYS_INLINE PartitionPage* PartitionPage::FromPointer(void* ptr) {
-  PartitionPage* page = PartitionPage::FromPointerNoAlignmentCheck(ptr);
-  // Checks that the pointer is a multiple of bucket size.
-  DCHECK(!((reinterpret_cast<uintptr_t>(ptr) -
-            reinterpret_cast<uintptr_t>(PartitionPage::ToPointer(page))) %
-           page->bucket->slot_size));
-  return page;
-}
-
-ALWAYS_INLINE const size_t* PartitionPage::get_raw_size_ptr() const {
-  // For single-slot buckets which span more than one partition page, we
-  // have some spare metadata space to store the raw allocation size. We
-  // can use this to report better statistics.
-  if (bucket->slot_size <= kMaxSystemPagesPerSlotSpan * kSystemPageSize)
-    return nullptr;
-
-  DCHECK((bucket->slot_size % kSystemPageSize) == 0);
-  DCHECK(bucket->is_direct_mapped() || bucket->get_slots_per_span() == 1);
-
-  const PartitionPage* the_next_page = this + 1;
-  return reinterpret_cast<const size_t*>(&the_next_page->freelist_head);
-}
-
-ALWAYS_INLINE size_t PartitionPage::get_raw_size() const {
-  const size_t* ptr = get_raw_size_ptr();
-  if (UNLIKELY(ptr != nullptr))
-    return *ptr;
-  return 0;
-}
-
-ALWAYS_INLINE PartitionRootBase* PartitionRootBase::FromPage(
-    PartitionPage* page) {
-  PartitionSuperPageExtentEntry* extent_entry =
-      reinterpret_cast<PartitionSuperPageExtentEntry*>(
-          reinterpret_cast<uintptr_t>(page) & kSystemPageBaseMask);
-  return extent_entry->root;
-}
-
-ALWAYS_INLINE bool PartitionPage::IsPointerValid(PartitionPage* page) {
-  PartitionRootBase* root = PartitionRootBase::FromPage(page);
-  return root->inverted_self == ~reinterpret_cast<uintptr_t>(root);
-}
-
-ALWAYS_INLINE void* PartitionBucket::Alloc(PartitionRootBase* root,
-                                           int flags,
-                                           size_t size) {
-  PartitionPage* page = this->active_pages_head;
-  // Check that this page is neither full nor freed.
-  DCHECK(page->num_allocated_slots >= 0);
-  void* ret = page->freelist_head;
-  if (LIKELY(ret != 0)) {
-    // If these DCHECKs fire, you probably corrupted memory.
-    // TODO(palmer): See if we can afford to make this a CHECK.
-    DCHECK(PartitionPage::IsPointerValid(page));
-    // All large allocations must go through the slow path to correctly
-    // update the size metadata.
-    DCHECK(page->get_raw_size() == 0);
-    PartitionFreelistEntry* new_head = PartitionFreelistEntry::Transform(
-        static_cast<PartitionFreelistEntry*>(ret)->next);
-    page->freelist_head = new_head;
-    page->num_allocated_slots++;
-  } else {
-    ret = this->SlowPathAlloc(root, flags, size);
-    // TODO(palmer): See if we can afford to make this a CHECK.
-    DCHECK(!ret ||
-           PartitionPage::IsPointerValid(PartitionPage::FromPointer(ret)));
-  }
-#if DCHECK_IS_ON()
-  if (!ret)
-    return 0;
-  // Fill the uninitialized pattern, and write the cookies.
-  page = PartitionPage::FromPointer(ret);
-  // TODO(ajwong): Can |page->bucket| ever not be |this|? If not, can this just
-  // be this->slot_size?
-  size_t new_slot_size = page->bucket->slot_size;
-  size_t raw_size = page->get_raw_size();
-  if (raw_size) {
-    DCHECK(raw_size == size);
-    new_slot_size = raw_size;
-  }
-  size_t no_cookie_size = PartitionCookieSizeAdjustSubtract(new_slot_size);
-  char* char_ret = static_cast<char*>(ret);
-  // The value given to the application is actually just after the cookie.
-  ret = char_ret + kCookieSize;
-
-  // Debug fill region kUninitializedByte and surround it with 2 cookies.
-  PartitionCookieWriteValue(char_ret);
-  memset(ret, kUninitializedByte, no_cookie_size);
-  PartitionCookieWriteValue(char_ret + kCookieSize + no_cookie_size);
-#endif
-  return ret;
-}
-
 ALWAYS_INLINE void* PartitionRoot::Alloc(size_t size, const char* type_name) {
 #if defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
   void* result = malloc(size);
@@ -861,12 +265,12 @@
   return result;
 #else
   size_t requested_size = size;
-  size = PartitionCookieSizeAdjustAdd(size);
+  size = internal::PartitionCookieSizeAdjustAdd(size);
   DCHECK(this->initialized);
   size_t index = size >> kBucketShift;
   DCHECK(index < this->num_buckets);
   DCHECK(size == index << kBucketShift);
-  PartitionBucket* bucket = &this->buckets()[index];
+  internal::PartitionBucket* bucket = &this->buckets()[index];
   void* result = bucket->Alloc(this, 0, size);
   PartitionAllocHooks::AllocationHookIfEnabled(result, requested_size,
                                                type_name);
@@ -874,39 +278,6 @@
 #endif  // defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
 }
 
-ALWAYS_INLINE void PartitionPage::Free(void* ptr) {
-// If these asserts fire, you probably corrupted memory.
-#if DCHECK_IS_ON()
-  size_t slot_size = this->bucket->slot_size;
-  size_t raw_size = get_raw_size();
-  if (raw_size)
-    slot_size = raw_size;
-  PartitionCookieCheckValue(ptr);
-  PartitionCookieCheckValue(reinterpret_cast<char*>(ptr) + slot_size -
-                            kCookieSize);
-  memset(ptr, kFreedByte, slot_size);
-#endif
-  DCHECK(this->num_allocated_slots);
-  // TODO(palmer): See if we can afford to make this a CHECK.
-  DCHECK(!freelist_head || PartitionPage::IsPointerValid(
-                               PartitionPage::FromPointer(freelist_head)));
-  CHECK(ptr != freelist_head);  // Catches an immediate double free.
-  // Look for double free one level deeper in debug.
-  DCHECK(!freelist_head ||
-         ptr != PartitionFreelistEntry::Transform(freelist_head->next));
-  PartitionFreelistEntry* entry = static_cast<PartitionFreelistEntry*>(ptr);
-  entry->next = PartitionFreelistEntry::Transform(freelist_head);
-  freelist_head = entry;
-  --this->num_allocated_slots;
-  if (UNLIKELY(this->num_allocated_slots <= 0)) {
-    FreeSlowPath();
-  } else {
-    // All single-slot allocations must go through the slow path to
-    // correctly update the size metadata.
-    DCHECK(get_raw_size() == 0);
-  }
-}
-
 ALWAYS_INLINE void PartitionFree(void* ptr) {
 #if defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
   free(ptr);
@@ -914,15 +285,15 @@
   // TODO(palmer): Check ptr alignment before continuing. Shall we do the check
   // inside PartitionCookieFreePointerAdjust?
   PartitionAllocHooks::FreeHookIfEnabled(ptr);
-  ptr = PartitionCookieFreePointerAdjust(ptr);
-  PartitionPage* page = PartitionPage::FromPointer(ptr);
+  ptr = internal::PartitionCookieFreePointerAdjust(ptr);
+  internal::PartitionPage* page = internal::PartitionPage::FromPointer(ptr);
   // TODO(palmer): See if we can afford to make this a CHECK.
-  DCHECK(PartitionPage::IsPointerValid(page));
+  DCHECK(internal::PartitionPage::IsPointerValid(page));
   page->Free(ptr);
 #endif
 }
 
-ALWAYS_INLINE PartitionBucket* PartitionGenericSizeToBucket(
+ALWAYS_INLINE internal::PartitionBucket* PartitionGenericSizeToBucket(
     PartitionRootGeneric* root,
     size_t size) {
   size_t order = kBitsPerSizeT - bits::CountLeadingZeroBitsSizeT(size);
@@ -931,7 +302,7 @@
                        (kGenericNumBucketsPerOrder - 1);
   // And if the remaining bits are non-zero we must bump the bucket up.
   size_t sub_order_index = size & root->order_sub_index_masks[order];
-  PartitionBucket* bucket =
+  internal::PartitionBucket* bucket =
       root->bucket_lookups[(order << kGenericNumBucketsPerOrderBits) +
                            order_index + !!sub_order_index];
   DCHECK(!bucket->slot_size || bucket->slot_size >= size);
@@ -950,8 +321,8 @@
 #else
   DCHECK(root->initialized);
   size_t requested_size = size;
-  size = PartitionCookieSizeAdjustAdd(size);
-  PartitionBucket* bucket = PartitionGenericSizeToBucket(root, size);
+  size = internal::PartitionCookieSizeAdjustAdd(size);
+  internal::PartitionBucket* bucket = PartitionGenericSizeToBucket(root, size);
   void* ret = nullptr;
   {
     subtle::SpinLock::Guard guard(root->lock);
@@ -977,10 +348,10 @@
     return;
 
   PartitionAllocHooks::FreeHookIfEnabled(ptr);
-  ptr = PartitionCookieFreePointerAdjust(ptr);
-  PartitionPage* page = PartitionPage::FromPointer(ptr);
+  ptr = internal::PartitionCookieFreePointerAdjust(ptr);
+  internal::PartitionPage* page = internal::PartitionPage::FromPointer(ptr);
   // TODO(palmer): See if we can afford to make this a CHECK.
-  DCHECK(PartitionPage::IsPointerValid(page));
+  DCHECK(internal::PartitionPage::IsPointerValid(page));
   {
     subtle::SpinLock::Guard guard(this->lock);
     page->Free(ptr);
@@ -988,29 +359,21 @@
 #endif
 }
 
-ALWAYS_INLINE size_t PartitionDirectMapSize(size_t size) {
-  // Caller must check that the size is not above the kGenericMaxDirectMapped
-  // limit before calling. This also guards against integer overflow in the
-  // calculation here.
-  DCHECK(size <= kGenericMaxDirectMapped);
-  return (size + kSystemPageOffsetMask) & kSystemPageBaseMask;
-}
-
 ALWAYS_INLINE size_t PartitionRootGeneric::ActualSize(size_t size) {
 #if defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
   return size;
 #else
   DCHECK(this->initialized);
-  size = PartitionCookieSizeAdjustAdd(size);
-  PartitionBucket* bucket = PartitionGenericSizeToBucket(this, size);
+  size = internal::PartitionCookieSizeAdjustAdd(size);
+  internal::PartitionBucket* bucket = PartitionGenericSizeToBucket(this, size);
   if (LIKELY(!bucket->is_direct_mapped())) {
     size = bucket->slot_size;
   } else if (size > kGenericMaxDirectMapped) {
     // Too large to allocate => return the size unchanged.
   } else {
-    size = PartitionDirectMapSize(size);
+    size = internal::PartitionBucket::get_direct_map_size(size);
   }
-  return PartitionCookieSizeAdjustSubtract(size);
+  return internal::PartitionCookieSizeAdjustSubtract(size);
 #endif
 }
 
@@ -1026,12 +389,12 @@
   // No need to lock here. Only |ptr| being freed by another thread could
   // cause trouble, and the caller is responsible for that not happening.
   DCHECK(PartitionAllocSupportsGetSize());
-  ptr = PartitionCookieFreePointerAdjust(ptr);
-  PartitionPage* page = PartitionPage::FromPointer(ptr);
+  ptr = internal::PartitionCookieFreePointerAdjust(ptr);
+  internal::PartitionPage* page = internal::PartitionPage::FromPointer(ptr);
   // TODO(palmer): See if we can afford to make this a CHECK.
-  DCHECK(PartitionPage::IsPointerValid(page));
+  DCHECK(internal::PartitionPage::IsPointerValid(page));
   size_t size = page->bucket->slot_size;
-  return PartitionCookieSizeAdjustSubtract(size);
+  return internal::PartitionCookieSizeAdjustSubtract(size);
 }
 
 template <size_t N>
@@ -1039,7 +402,7 @@
  public:
   SizeSpecificPartitionAllocator() {
     memset(actual_buckets_, 0,
-           sizeof(PartitionBucket) * arraysize(actual_buckets_));
+           sizeof(internal::PartitionBucket) * arraysize(actual_buckets_));
   }
   ~SizeSpecificPartitionAllocator() = default;
   static const size_t kMaxAllocation = N - kAllocationGranularity;
@@ -1049,7 +412,7 @@
 
  private:
   PartitionRoot partition_root_;
-  PartitionBucket actual_buckets_[kNumBuckets];
+  internal::PartitionBucket actual_buckets_[kNumBuckets];
 };
 
 class BASE_EXPORT PartitionAllocatorGeneric {
diff --git a/base/allocator/partition_allocator/partition_alloc_constants.h b/base/allocator/partition_allocator/partition_alloc_constants.h
new file mode 100644
index 0000000..c4afd027
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_alloc_constants.h
@@ -0,0 +1,159 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ALLOC_CONSTANTS_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ALLOC_CONSTANTS_H_
+
+#include "base/allocator/partition_allocator/page_allocator_constants.h"
+#include "base/bits.h"
+#include "base/logging.h"
+
+namespace base {
+
+// Allocation granularity of sizeof(void*) bytes.
+static const size_t kAllocationGranularity = sizeof(void*);
+static const size_t kAllocationGranularityMask = kAllocationGranularity - 1;
+static const size_t kBucketShift = (kAllocationGranularity == 8) ? 3 : 2;
+
+// Underlying partition storage pages are a power-of-two size. It is typical
+// for a partition page to be based on multiple system pages. Most references to
+// "page" refer to partition pages.
+// We also have the concept of "super pages" -- these are the underlying system
+// allocations we make. Super pages contain multiple partition pages inside them
+// and include space for a small amount of metadata per partition page.
+// Inside super pages, we store "slot spans". A slot span is a continguous range
+// of one or more partition pages that stores allocations of the same size.
+// Slot span sizes are adjusted depending on the allocation size, to make sure
+// the packing does not lead to unused (wasted) space at the end of the last
+// system page of the span. For our current max slot span size of 64k and other
+// constant values, we pack _all_ PartitionRootGeneric::Alloc() sizes perfectly
+// up against the end of a system page.
+#if defined(_MIPS_ARCH_LOONGSON)
+static const size_t kPartitionPageShift = 16;  // 64KB
+#else
+static const size_t kPartitionPageShift = 14;  // 16KB
+#endif
+static const size_t kPartitionPageSize = 1 << kPartitionPageShift;
+static const size_t kPartitionPageOffsetMask = kPartitionPageSize - 1;
+static const size_t kPartitionPageBaseMask = ~kPartitionPageOffsetMask;
+static const size_t kMaxPartitionPagesPerSlotSpan = 4;
+
+// To avoid fragmentation via never-used freelist entries, we hand out partition
+// freelist sections gradually, in units of the dominant system page size.
+// What we're actually doing is avoiding filling the full partition page (16 KB)
+// with freelist pointers right away. Writing freelist pointers will fault and
+// dirty a private page, which is very wasteful if we never actually store
+// objects there.
+static const size_t kNumSystemPagesPerPartitionPage =
+    kPartitionPageSize / kSystemPageSize;
+static const size_t kMaxSystemPagesPerSlotSpan =
+    kNumSystemPagesPerPartitionPage * kMaxPartitionPagesPerSlotSpan;
+
+// We reserve virtual address space in 2MB chunks (aligned to 2MB as well).
+// These chunks are called "super pages". We do this so that we can store
+// metadata in the first few pages of each 2MB aligned section. This leads to
+// a very fast free(). We specifically choose 2MB because this virtual address
+// block represents a full but single PTE allocation on ARM, ia32 and x64.
+//
+// The layout of the super page is as follows. The sizes below are the same
+// for 32 bit and 64 bit.
+//
+//   | Guard page (4KB)    |
+//   | Metadata page (4KB) |
+//   | Guard pages (8KB)   |
+//   | Slot span           |
+//   | Slot span           |
+//   | ...                 |
+//   | Slot span           |
+//   | Guard page (4KB)    |
+//
+//   - Each slot span is a contiguous range of one or more PartitionPages.
+//   - The metadata page has the following format. Note that the PartitionPage
+//     that is not at the head of a slot span is "unused". In other words,
+//     the metadata for the slot span is stored only in the first PartitionPage
+//     of the slot span. Metadata accesses to other PartitionPages are
+//     redirected to the first PartitionPage.
+//
+//     | SuperPageExtentEntry (32B)                 |
+//     | PartitionPage of slot span 1 (32B, used)   |
+//     | PartitionPage of slot span 1 (32B, unused) |
+//     | PartitionPage of slot span 1 (32B, unused) |
+//     | PartitionPage of slot span 2 (32B, used)   |
+//     | PartitionPage of slot span 3 (32B, used)   |
+//     | ...                                        |
+//     | PartitionPage of slot span N (32B, unused) |
+//
+// A direct mapped page has a similar layout to fake it looking like a super
+// page:
+//
+//     | Guard page (4KB)     |
+//     | Metadata page (4KB)  |
+//     | Guard pages (8KB)    |
+//     | Direct mapped object |
+//     | Guard page (4KB)     |
+//
+//    - The metadata page has the following layout:
+//
+//     | SuperPageExtentEntry (32B)    |
+//     | PartitionPage (32B)           |
+//     | PartitionBucket (32B)         |
+//     | PartitionDirectMapExtent (8B) |
+static const size_t kSuperPageShift = 21;  // 2MB
+static const size_t kSuperPageSize = 1 << kSuperPageShift;
+static const size_t kSuperPageOffsetMask = kSuperPageSize - 1;
+static const size_t kSuperPageBaseMask = ~kSuperPageOffsetMask;
+static const size_t kNumPartitionPagesPerSuperPage =
+    kSuperPageSize / kPartitionPageSize;
+
+// The following kGeneric* constants apply to the generic variants of the API.
+// The "order" of an allocation is closely related to the power-of-two size of
+// the allocation. More precisely, the order is the bit index of the
+// most-significant-bit in the allocation size, where the bit numbers starts
+// at index 1 for the least-significant-bit.
+// In terms of allocation sizes, order 0 covers 0, order 1 covers 1, order 2
+// covers 2->3, order 3 covers 4->7, order 4 covers 8->15.
+static const size_t kGenericMinBucketedOrder = 4;  // 8 bytes.
+static const size_t kGenericMaxBucketedOrder =
+    20;  // Largest bucketed order is 1<<(20-1) (storing 512KB -> almost 1MB)
+static const size_t kGenericNumBucketedOrders =
+    (kGenericMaxBucketedOrder - kGenericMinBucketedOrder) + 1;
+// Eight buckets per order (for the higher orders), e.g. order 8 is 128, 144,
+// 160, ..., 240:
+static const size_t kGenericNumBucketsPerOrderBits = 3;
+static const size_t kGenericNumBucketsPerOrder =
+    1 << kGenericNumBucketsPerOrderBits;
+static const size_t kGenericNumBuckets =
+    kGenericNumBucketedOrders * kGenericNumBucketsPerOrder;
+static const size_t kGenericSmallestBucket = 1
+                                             << (kGenericMinBucketedOrder - 1);
+static const size_t kGenericMaxBucketSpacing =
+    1 << ((kGenericMaxBucketedOrder - 1) - kGenericNumBucketsPerOrderBits);
+static const size_t kGenericMaxBucketed =
+    (1 << (kGenericMaxBucketedOrder - 1)) +
+    ((kGenericNumBucketsPerOrder - 1) * kGenericMaxBucketSpacing);
+static const size_t kGenericMinDirectMappedDownsize =
+    kGenericMaxBucketed +
+    1;  // Limit when downsizing a direct mapping using realloc().
+static const size_t kGenericMaxDirectMapped =
+    (1UL << 31) + kPageAllocationGranularity;  // 2 GB plus one more page.
+static const size_t kBitsPerSizeT = sizeof(void*) * CHAR_BIT;
+
+// Constant for the memory reclaim logic.
+static const size_t kMaxFreeableSpans = 16;
+
+// If the total size in bytes of allocated but not committed pages exceeds this
+// value (probably it is a "out of virtual address space" crash),
+// a special crash stack trace is generated at |PartitionOutOfMemory|.
+// This is to distinguish "out of virtual address space" from
+// "out of physical memory" in crash reports.
+static const size_t kReasonableSizeOfUnusedPages = 1024 * 1024 * 1024;  // 1GB
+
+// Flags for PartitionAllocGenericFlags.
+enum PartitionAllocFlags {
+  PartitionAllocReturnNull = 1 << 0,
+};
+
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ALLOC_CONSTANTS_H_
diff --git a/base/allocator/partition_allocator/partition_alloc_unittest.cc b/base/allocator/partition_allocator/partition_alloc_unittest.cc
index 00f77f8..f8081fc 100644
--- a/base/allocator/partition_allocator/partition_alloc_unittest.cc
+++ b/base/allocator/partition_allocator/partition_alloc_unittest.cc
@@ -27,6 +27,12 @@
 
 #if !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
 
+// Because there is so much deep inspection of the internal objects,
+// explicitly annotating the namespaces for commonly expected objects makes the
+// code unreadable. Prefer using directives instead.
+using base::internal::PartitionBucket;
+using base::internal::PartitionPage;
+
 namespace {
 
 constexpr size_t kTestMaxAllocation = base::kSystemPageSize;
@@ -84,6 +90,14 @@
 
 namespace base {
 
+// NOTE: Though this test actually excercises interfaces inside the ::base
+// namespace, the unittest is inside the ::base::internal spaces because a
+// portion of the test expectations require inspecting objects and behavior
+// in the ::base::internal namespace. An alternate formulation would be to
+// explicitly add using statements for each inspected type but this felt more
+// readable.
+namespace internal {
+
 const size_t kTestAllocSize = 16;
 #if !DCHECK_IS_ON()
 const size_t kPointerOffset = 0;
@@ -2089,6 +2103,7 @@
   generic_allocator.root()->Free(ptr);
 }
 
+}  // namespace internal
 }  // namespace base
 
 #endif  // !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
diff --git a/base/allocator/partition_allocator/partition_bucket-inl.h b/base/allocator/partition_allocator/partition_bucket-inl.h
new file mode 100644
index 0000000..5e435aa
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_bucket-inl.h
@@ -0,0 +1,74 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_INL_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_INL_H_
+
+#include "base/allocator/partition_allocator/partition_bucket.h"
+#include "base/allocator/partition_allocator/partition_cookie.h"
+#include "base/allocator/partition_allocator/partition_freelist_entry.h"
+#include "base/allocator/partition_allocator/partition_page.h"
+#include "base/compiler_specific.h"
+#include "base/logging.h"
+
+namespace base {
+namespace internal {
+
+// TODO(ajwong): Move this to PartitionRootBase. Likely can remove this -inl.h
+// file.
+ALWAYS_INLINE void* PartitionBucket::Alloc(PartitionRootBase* root,
+                                           int flags,
+                                           size_t size) {
+  PartitionPage* page = this->active_pages_head;
+  // Check that this page is neither full nor freed.
+  DCHECK(page->num_allocated_slots >= 0);
+  void* ret = page->freelist_head;
+  if (LIKELY(ret != 0)) {
+    // If these DCHECKs fire, you probably corrupted memory.
+    // TODO(palmer): See if we can afford to make this a CHECK.
+    DCHECK(PartitionPage::IsPointerValid(page));
+    // All large allocations must go through the slow path to correctly
+    // update the size metadata.
+    DCHECK(page->get_raw_size() == 0);
+    internal::PartitionFreelistEntry* new_head =
+        internal::PartitionFreelistEntry::Transform(
+            static_cast<internal::PartitionFreelistEntry*>(ret)->next);
+    page->freelist_head = new_head;
+    page->num_allocated_slots++;
+  } else {
+    ret = this->SlowPathAlloc(root, flags, size);
+    // TODO(palmer): See if we can afford to make this a CHECK.
+    DCHECK(!ret ||
+           PartitionPage::IsPointerValid(PartitionPage::FromPointer(ret)));
+  }
+#if DCHECK_IS_ON()
+  if (!ret)
+    return 0;
+  // Fill the uninitialized pattern, and write the cookies.
+  page = PartitionPage::FromPointer(ret);
+  // TODO(ajwong): Can |page->bucket| ever not be |this|? If not, can this just
+  // be this->slot_size?
+  size_t new_slot_size = page->bucket->slot_size;
+  size_t raw_size = page->get_raw_size();
+  if (raw_size) {
+    DCHECK(raw_size == size);
+    new_slot_size = raw_size;
+  }
+  size_t no_cookie_size = PartitionCookieSizeAdjustSubtract(new_slot_size);
+  char* char_ret = static_cast<char*>(ret);
+  // The value given to the application is actually just after the cookie.
+  ret = char_ret + kCookieSize;
+
+  // Debug fill region kUninitializedByte and surround it with 2 cookies.
+  PartitionCookieWriteValue(char_ret);
+  memset(ret, kUninitializedByte, no_cookie_size);
+  PartitionCookieWriteValue(char_ret + kCookieSize + no_cookie_size);
+#endif
+  return ret;
+}
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_INL_H_
diff --git a/base/allocator/partition_allocator/partition_bucket.cc b/base/allocator/partition_allocator/partition_bucket.cc
new file mode 100644
index 0000000..a9185a3
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_bucket.cc
@@ -0,0 +1,554 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/allocator/partition_allocator/oom.h"
+#include "base/allocator/partition_allocator/page_allocator.h"
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+#include "base/allocator/partition_allocator/partition_bucket-inl.h"
+#include "base/allocator/partition_allocator/partition_direct_map_extent-inl.h"
+#include "base/allocator/partition_allocator/partition_oom.h"
+#include "base/allocator/partition_allocator/partition_page-inl.h"
+#include "base/allocator/partition_allocator/partition_root_base-inl.h"
+#include "build/build_config.h"
+
+namespace base {
+namespace internal {
+
+namespace {
+
+ALWAYS_INLINE PartitionPage* PartitionDirectMap(PartitionRootBase* root,
+                                                int flags,
+                                                size_t raw_size) {
+  size_t size = PartitionBucket::get_direct_map_size(raw_size);
+
+  // Because we need to fake looking like a super page, we need to allocate
+  // a bunch of system pages more than "size":
+  // - The first few system pages are the partition page in which the super
+  // page metadata is stored. We fault just one system page out of a partition
+  // page sized clump.
+  // - We add a trailing guard page on 32-bit (on 64-bit we rely on the
+  // massive address space plus randomization instead).
+  size_t map_size = size + kPartitionPageSize;
+#if !defined(ARCH_CPU_64_BITS)
+  map_size += kSystemPageSize;
+#endif
+  // Round up to the allocation granularity.
+  map_size += kPageAllocationGranularityOffsetMask;
+  map_size &= kPageAllocationGranularityBaseMask;
+
+  // TODO: these pages will be zero-filled. Consider internalizing an
+  // allocZeroed() API so we can avoid a memset() entirely in this case.
+  char* ptr = reinterpret_cast<char*>(
+      AllocPages(nullptr, map_size, kSuperPageSize, PageReadWrite));
+  if (UNLIKELY(!ptr))
+    return nullptr;
+
+  size_t committed_page_size = size + kSystemPageSize;
+  root->total_size_of_direct_mapped_pages += committed_page_size;
+  root->IncreaseCommittedPages(committed_page_size);
+
+  char* slot = ptr + kPartitionPageSize;
+  CHECK(SetSystemPagesAccess(ptr + (kSystemPageSize * 2),
+                             kPartitionPageSize - (kSystemPageSize * 2),
+                             PageInaccessible));
+#if !defined(ARCH_CPU_64_BITS)
+  CHECK(SetSystemPagesAccess(ptr, kSystemPageSize, PageInaccessible));
+  CHECK(SetSystemPagesAccess(slot + size, kSystemPageSize, PageInaccessible));
+#endif
+
+  PartitionSuperPageExtentEntry* extent =
+      reinterpret_cast<PartitionSuperPageExtentEntry*>(
+          PartitionSuperPageToMetadataArea(ptr));
+  extent->root = root;
+  // The new structures are all located inside a fresh system page so they
+  // will all be zeroed out. These DCHECKs are for documentation.
+  DCHECK(!extent->super_page_base);
+  DCHECK(!extent->super_pages_end);
+  DCHECK(!extent->next);
+  PartitionPage* page = PartitionPage::FromPointerNoAlignmentCheck(slot);
+  PartitionBucket* bucket = reinterpret_cast<PartitionBucket*>(
+      reinterpret_cast<char*>(page) + (kPageMetadataSize * 2));
+  DCHECK(!page->next_page);
+  DCHECK(!page->num_allocated_slots);
+  DCHECK(!page->num_unprovisioned_slots);
+  DCHECK(!page->page_offset);
+  DCHECK(!page->empty_cache_index);
+  page->bucket = bucket;
+  page->freelist_head = reinterpret_cast<PartitionFreelistEntry*>(slot);
+  PartitionFreelistEntry* next_entry =
+      reinterpret_cast<PartitionFreelistEntry*>(slot);
+  next_entry->next = PartitionFreelistEntry::Transform(nullptr);
+
+  DCHECK(!bucket->active_pages_head);
+  DCHECK(!bucket->empty_pages_head);
+  DCHECK(!bucket->decommitted_pages_head);
+  DCHECK(!bucket->num_system_pages_per_slot_span);
+  DCHECK(!bucket->num_full_pages);
+  bucket->slot_size = size;
+
+  PartitionDirectMapExtent* map_extent =
+      PartitionDirectMapExtent::FromPage(page);
+  map_extent->map_size = map_size - kPartitionPageSize - kSystemPageSize;
+  map_extent->bucket = bucket;
+
+  // Maintain the doubly-linked list of all direct mappings.
+  map_extent->next_extent = root->direct_map_list;
+  if (map_extent->next_extent)
+    map_extent->next_extent->prev_extent = map_extent;
+  map_extent->prev_extent = nullptr;
+  root->direct_map_list = map_extent;
+
+  return page;
+}
+
+}  // namespace
+
+// static
+PartitionBucket PartitionBucket::sentinel_bucket_;
+
+PartitionBucket* PartitionBucket::get_sentinel_bucket() {
+  return &sentinel_bucket_;
+}
+
+// TODO(ajwong): This seems to interact badly with
+// get_pages_per_slot_span() which rounds the value from this up to a
+// multiple of kNumSystemPagesPerPartitionPage (aka 4) anyways.
+// http://crbug.com/776537
+//
+// TODO(ajwong): The waste calculation seems wrong. The PTE usage should cover
+// both used and unsed pages.
+// http://crbug.com/776537
+uint8_t PartitionBucket::get_system_pages_per_slot_span() {
+  // This works out reasonably for the current bucket sizes of the generic
+  // allocator, and the current values of partition page size and constants.
+  // Specifically, we have enough room to always pack the slots perfectly into
+  // some number of system pages. The only waste is the waste associated with
+  // unfaulted pages (i.e. wasted address space).
+  // TODO: we end up using a lot of system pages for very small sizes. For
+  // example, we'll use 12 system pages for slot size 24. The slot size is
+  // so small that the waste would be tiny with just 4, or 1, system pages.
+  // Later, we can investigate whether there are anti-fragmentation benefits
+  // to using fewer system pages.
+  double best_waste_ratio = 1.0f;
+  uint16_t best_pages = 0;
+  if (this->slot_size > kMaxSystemPagesPerSlotSpan * kSystemPageSize) {
+    // TODO(ajwong): Why is there a DCHECK here for this?
+    // http://crbug.com/776537
+    DCHECK(!(this->slot_size % kSystemPageSize));
+    best_pages = static_cast<uint16_t>(this->slot_size / kSystemPageSize);
+    // TODO(ajwong): Should this be checking against
+    // kMaxSystemPagesPerSlotSpan or numeric_limits<uint8_t>::max?
+    // http://crbug.com/776537
+    CHECK(best_pages < (1 << 8));
+    return static_cast<uint8_t>(best_pages);
+  }
+  DCHECK(this->slot_size <= kMaxSystemPagesPerSlotSpan * kSystemPageSize);
+  for (uint16_t i = kNumSystemPagesPerPartitionPage - 1;
+       i <= kMaxSystemPagesPerSlotSpan; ++i) {
+    size_t page_size = kSystemPageSize * i;
+    size_t num_slots = page_size / this->slot_size;
+    size_t waste = page_size - (num_slots * this->slot_size);
+    // Leaving a page unfaulted is not free; the page will occupy an empty page
+    // table entry.  Make a simple attempt to account for that.
+    //
+    // TODO(ajwong): This looks wrong. PTEs are allocated for all pages
+    // regardless of whether or not they are wasted. Should it just
+    // be waste += i * sizeof(void*)?
+    // http://crbug.com/776537
+    size_t num_remainder_pages = i & (kNumSystemPagesPerPartitionPage - 1);
+    size_t num_unfaulted_pages =
+        num_remainder_pages
+            ? (kNumSystemPagesPerPartitionPage - num_remainder_pages)
+            : 0;
+    waste += sizeof(void*) * num_unfaulted_pages;
+    double waste_ratio = (double)waste / (double)page_size;
+    if (waste_ratio < best_waste_ratio) {
+      best_waste_ratio = waste_ratio;
+      best_pages = i;
+    }
+  }
+  DCHECK(best_pages > 0);
+  CHECK(best_pages <= kMaxSystemPagesPerSlotSpan);
+  return static_cast<uint8_t>(best_pages);
+}
+
+void PartitionBucket::Init(uint32_t new_slot_size) {
+  slot_size = new_slot_size;
+  active_pages_head = PartitionPage::get_sentinel_page();
+  empty_pages_head = nullptr;
+  decommitted_pages_head = nullptr;
+  num_full_pages = 0;
+  num_system_pages_per_slot_span = get_system_pages_per_slot_span();
+}
+
+NOINLINE void PartitionBucket::OnFull() {
+  OOM_CRASH();
+}
+
+ALWAYS_INLINE void* PartitionBucket::AllocNewSlotSpan(
+    PartitionRootBase* root,
+    int flags,
+    uint16_t num_partition_pages) {
+  DCHECK(!(reinterpret_cast<uintptr_t>(root->next_partition_page) %
+           kPartitionPageSize));
+  DCHECK(!(reinterpret_cast<uintptr_t>(root->next_partition_page_end) %
+           kPartitionPageSize));
+  DCHECK(num_partition_pages <= kNumPartitionPagesPerSuperPage);
+  size_t total_size = kPartitionPageSize * num_partition_pages;
+  size_t num_partition_pages_left =
+      (root->next_partition_page_end - root->next_partition_page) >>
+      kPartitionPageShift;
+  if (LIKELY(num_partition_pages_left >= num_partition_pages)) {
+    // In this case, we can still hand out pages from the current super page
+    // allocation.
+    char* ret = root->next_partition_page;
+
+    // Fresh System Pages in the SuperPages are decommited. Commit them
+    // before vending them back.
+    CHECK(SetSystemPagesAccess(ret, total_size, PageReadWrite));
+
+    root->next_partition_page += total_size;
+    root->IncreaseCommittedPages(total_size);
+    return ret;
+  }
+
+  // Need a new super page. We want to allocate super pages in a continguous
+  // address region as much as possible. This is important for not causing
+  // page table bloat and not fragmenting address spaces in 32 bit
+  // architectures.
+  char* requestedAddress = root->next_super_page;
+  char* super_page = reinterpret_cast<char*>(AllocPages(
+      requestedAddress, kSuperPageSize, kSuperPageSize, PageReadWrite));
+  if (UNLIKELY(!super_page))
+    return nullptr;
+
+  root->total_size_of_super_pages += kSuperPageSize;
+  root->IncreaseCommittedPages(total_size);
+
+  // |total_size| MUST be less than kSuperPageSize - (kPartitionPageSize*2).
+  // This is a trustworthy value because num_partition_pages is not user
+  // controlled.
+  //
+  // TODO(ajwong): Introduce a DCHECK.
+  root->next_super_page = super_page + kSuperPageSize;
+  char* ret = super_page + kPartitionPageSize;
+  root->next_partition_page = ret + total_size;
+  root->next_partition_page_end = root->next_super_page - kPartitionPageSize;
+  // Make the first partition page in the super page a guard page, but leave a
+  // hole in the middle.
+  // This is where we put page metadata and also a tiny amount of extent
+  // metadata.
+  CHECK(SetSystemPagesAccess(super_page, kSystemPageSize, PageInaccessible));
+  CHECK(SetSystemPagesAccess(super_page + (kSystemPageSize * 2),
+                             kPartitionPageSize - (kSystemPageSize * 2),
+                             PageInaccessible));
+  //  CHECK(SetSystemPagesAccess(super_page + (kSuperPageSize -
+  //  kPartitionPageSize),
+  //                             kPartitionPageSize, PageInaccessible));
+  // All remaining slotspans for the unallocated PartitionPages inside the
+  // SuperPage are conceptually decommitted. Correctly set the state here
+  // so they do not occupy resources.
+  //
+  // TODO(ajwong): Refactor Page Allocator API so the SuperPage comes in
+  // decommited initially.
+  CHECK(SetSystemPagesAccess(super_page + kPartitionPageSize + total_size,
+                             (kSuperPageSize - kPartitionPageSize - total_size),
+                             PageInaccessible));
+
+  // If we were after a specific address, but didn't get it, assume that
+  // the system chose a lousy address. Here most OS'es have a default
+  // algorithm that isn't randomized. For example, most Linux
+  // distributions will allocate the mapping directly before the last
+  // successful mapping, which is far from random. So we just get fresh
+  // randomness for the next mapping attempt.
+  if (requestedAddress && requestedAddress != super_page)
+    root->next_super_page = nullptr;
+
+  // We allocated a new super page so update super page metadata.
+  // First check if this is a new extent or not.
+  PartitionSuperPageExtentEntry* latest_extent =
+      reinterpret_cast<PartitionSuperPageExtentEntry*>(
+          PartitionSuperPageToMetadataArea(super_page));
+  // By storing the root in every extent metadata object, we have a fast way
+  // to go from a pointer within the partition to the root object.
+  latest_extent->root = root;
+  // Most new extents will be part of a larger extent, and these three fields
+  // are unused, but we initialize them to 0 so that we get a clear signal
+  // in case they are accidentally used.
+  latest_extent->super_page_base = nullptr;
+  latest_extent->super_pages_end = nullptr;
+  latest_extent->next = nullptr;
+
+  PartitionSuperPageExtentEntry* current_extent = root->current_extent;
+  bool isNewExtent = (super_page != requestedAddress);
+  if (UNLIKELY(isNewExtent)) {
+    if (UNLIKELY(!current_extent)) {
+      DCHECK(!root->first_extent);
+      root->first_extent = latest_extent;
+    } else {
+      DCHECK(current_extent->super_page_base);
+      current_extent->next = latest_extent;
+    }
+    root->current_extent = latest_extent;
+    latest_extent->super_page_base = super_page;
+    latest_extent->super_pages_end = super_page + kSuperPageSize;
+  } else {
+    // We allocated next to an existing extent so just nudge the size up a
+    // little.
+    DCHECK(current_extent->super_pages_end);
+    current_extent->super_pages_end += kSuperPageSize;
+    DCHECK(ret >= current_extent->super_page_base &&
+           ret < current_extent->super_pages_end);
+  }
+  return ret;
+}
+
+ALWAYS_INLINE uint16_t PartitionBucket::get_pages_per_slot_span() {
+  // Rounds up to nearest multiple of kNumSystemPagesPerPartitionPage.
+  return (num_system_pages_per_slot_span +
+          (kNumSystemPagesPerPartitionPage - 1)) /
+         kNumSystemPagesPerPartitionPage;
+}
+
+ALWAYS_INLINE void PartitionBucket::InitializeSlotSpan(PartitionPage* page) {
+  // The bucket never changes. We set it up once.
+  page->bucket = this;
+  page->empty_cache_index = -1;
+
+  page->Reset();
+
+  // If this page has just a single slot, do not set up page offsets for any
+  // page metadata other than the first one. This ensures that attempts to
+  // touch invalid page metadata fail.
+  if (page->num_unprovisioned_slots == 1)
+    return;
+
+  uint16_t num_partition_pages = get_pages_per_slot_span();
+  char* page_char_ptr = reinterpret_cast<char*>(page);
+  for (uint16_t i = 1; i < num_partition_pages; ++i) {
+    page_char_ptr += kPageMetadataSize;
+    PartitionPage* secondary_page =
+        reinterpret_cast<PartitionPage*>(page_char_ptr);
+    secondary_page->page_offset = i;
+  }
+}
+
+ALWAYS_INLINE char* PartitionBucket::AllocAndFillFreelist(PartitionPage* page) {
+  DCHECK(page != PartitionPage::get_sentinel_page());
+  uint16_t num_slots = page->num_unprovisioned_slots;
+  DCHECK(num_slots);
+  // We should only get here when _every_ slot is either used or unprovisioned.
+  // (The third state is "on the freelist". If we have a non-empty freelist, we
+  // should not get here.)
+  DCHECK(num_slots + page->num_allocated_slots == this->get_slots_per_span());
+  // Similarly, make explicitly sure that the freelist is empty.
+  DCHECK(!page->freelist_head);
+  DCHECK(page->num_allocated_slots >= 0);
+
+  size_t size = this->slot_size;
+  char* base = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
+  char* return_object = base + (size * page->num_allocated_slots);
+  char* first_freelist_pointer = return_object + size;
+  char* first_freelist_pointer_extent =
+      first_freelist_pointer + sizeof(PartitionFreelistEntry*);
+  // Our goal is to fault as few system pages as possible. We calculate the
+  // page containing the "end" of the returned slot, and then allow freelist
+  // pointers to be written up to the end of that page.
+  char* sub_page_limit = reinterpret_cast<char*>(
+      RoundUpToSystemPage(reinterpret_cast<size_t>(first_freelist_pointer)));
+  char* slots_limit = return_object + (size * num_slots);
+  char* freelist_limit = sub_page_limit;
+  if (UNLIKELY(slots_limit < freelist_limit))
+    freelist_limit = slots_limit;
+
+  uint16_t num_new_freelist_entries = 0;
+  if (LIKELY(first_freelist_pointer_extent <= freelist_limit)) {
+    // Only consider used space in the slot span. If we consider wasted
+    // space, we may get an off-by-one when a freelist pointer fits in the
+    // wasted space, but a slot does not.
+    // We know we can fit at least one freelist pointer.
+    num_new_freelist_entries = 1;
+    // Any further entries require space for the whole slot span.
+    num_new_freelist_entries += static_cast<uint16_t>(
+        (freelist_limit - first_freelist_pointer_extent) / size);
+  }
+
+  // We always return an object slot -- that's the +1 below.
+  // We do not neccessarily create any new freelist entries, because we cross
+  // sub page boundaries frequently for large bucket sizes.
+  DCHECK(num_new_freelist_entries + 1 <= num_slots);
+  num_slots -= (num_new_freelist_entries + 1);
+  page->num_unprovisioned_slots = num_slots;
+  page->num_allocated_slots++;
+
+  if (LIKELY(num_new_freelist_entries)) {
+    char* freelist_pointer = first_freelist_pointer;
+    PartitionFreelistEntry* entry =
+        reinterpret_cast<PartitionFreelistEntry*>(freelist_pointer);
+    page->freelist_head = entry;
+    while (--num_new_freelist_entries) {
+      freelist_pointer += size;
+      PartitionFreelistEntry* next_entry =
+          reinterpret_cast<PartitionFreelistEntry*>(freelist_pointer);
+      entry->next = PartitionFreelistEntry::Transform(next_entry);
+      entry = next_entry;
+    }
+    entry->next = PartitionFreelistEntry::Transform(nullptr);
+  } else {
+    page->freelist_head = nullptr;
+  }
+  return return_object;
+}
+
+bool PartitionBucket::SetNewActivePage() {
+  PartitionPage* page = this->active_pages_head;
+  if (page == PartitionPage::get_sentinel_page())
+    return false;
+
+  PartitionPage* next_page;
+
+  for (; page; page = next_page) {
+    next_page = page->next_page;
+    DCHECK(page->bucket == this);
+    DCHECK(page != this->empty_pages_head);
+    DCHECK(page != this->decommitted_pages_head);
+
+    if (LIKELY(page->is_active())) {
+      // This page is usable because it has freelist entries, or has
+      // unprovisioned slots we can create freelist entries from.
+      this->active_pages_head = page;
+      return true;
+    }
+
+    // Deal with empty and decommitted pages.
+    if (LIKELY(page->is_empty())) {
+      page->next_page = this->empty_pages_head;
+      this->empty_pages_head = page;
+    } else if (LIKELY(page->is_decommitted())) {
+      page->next_page = this->decommitted_pages_head;
+      this->decommitted_pages_head = page;
+    } else {
+      DCHECK(page->is_full());
+      // If we get here, we found a full page. Skip over it too, and also
+      // tag it as full (via a negative value). We need it tagged so that
+      // free'ing can tell, and move it back into the active page list.
+      page->num_allocated_slots = -page->num_allocated_slots;
+      ++this->num_full_pages;
+      // num_full_pages is a uint16_t for efficient packing so guard against
+      // overflow to be safe.
+      if (UNLIKELY(!this->num_full_pages))
+        OnFull();
+      // Not necessary but might help stop accidents.
+      page->next_page = nullptr;
+    }
+  }
+
+  this->active_pages_head = PartitionPage::get_sentinel_page();
+  return false;
+}
+
+void* PartitionBucket::SlowPathAlloc(PartitionRootBase* root,
+                                     int flags,
+                                     size_t size) {
+  // The slow path is called when the freelist is empty.
+  DCHECK(!this->active_pages_head->freelist_head);
+
+  PartitionPage* new_page = nullptr;
+
+  // For the PartitionRootGeneric::Alloc() API, we have a bunch of buckets
+  // marked as special cases. We bounce them through to the slow path so that
+  // we can still have a blazing fast hot path due to lack of corner-case
+  // branches.
+  //
+  // Note: The ordering of the conditionals matter! In particular,
+  // SetNewActivePage() has a side-effect even when returning
+  // false where it sweeps the active page list and may move things into
+  // the empty or decommitted lists which affects the subsequent conditional.
+  bool return_null = flags & PartitionAllocReturnNull;
+  if (UNLIKELY(this->is_direct_mapped())) {
+    DCHECK(size > kGenericMaxBucketed);
+    DCHECK(this == get_sentinel_bucket());
+    DCHECK(this->active_pages_head == PartitionPage::get_sentinel_page());
+    if (size > kGenericMaxDirectMapped) {
+      if (return_null)
+        return nullptr;
+      PartitionExcessiveAllocationSize();
+    }
+    new_page = PartitionDirectMap(root, flags, size);
+  } else if (LIKELY(this->SetNewActivePage())) {
+    // First, did we find an active page in the active pages list?
+    new_page = this->active_pages_head;
+    DCHECK(new_page->is_active());
+  } else if (LIKELY(this->empty_pages_head != nullptr) ||
+             LIKELY(this->decommitted_pages_head != nullptr)) {
+    // Second, look in our lists of empty and decommitted pages.
+    // Check empty pages first, which are preferred, but beware that an
+    // empty page might have been decommitted.
+    while (LIKELY((new_page = this->empty_pages_head) != nullptr)) {
+      DCHECK(new_page->bucket == this);
+      DCHECK(new_page->is_empty() || new_page->is_decommitted());
+      this->empty_pages_head = new_page->next_page;
+      // Accept the empty page unless it got decommitted.
+      if (new_page->freelist_head) {
+        new_page->next_page = nullptr;
+        break;
+      }
+      DCHECK(new_page->is_decommitted());
+      new_page->next_page = this->decommitted_pages_head;
+      this->decommitted_pages_head = new_page;
+    }
+    if (UNLIKELY(!new_page) &&
+        LIKELY(this->decommitted_pages_head != nullptr)) {
+      new_page = this->decommitted_pages_head;
+      DCHECK(new_page->bucket == this);
+      DCHECK(new_page->is_decommitted());
+      this->decommitted_pages_head = new_page->next_page;
+      void* addr = PartitionPage::ToPointer(new_page);
+      root->RecommitSystemPages(addr, new_page->bucket->get_bytes_per_span());
+      new_page->Reset();
+    }
+    DCHECK(new_page);
+  } else {
+    // Third. If we get here, we need a brand new page.
+    uint16_t num_partition_pages = this->get_pages_per_slot_span();
+    void* rawPages = AllocNewSlotSpan(root, flags, num_partition_pages);
+    if (LIKELY(rawPages != nullptr)) {
+      new_page = PartitionPage::FromPointerNoAlignmentCheck(rawPages);
+      InitializeSlotSpan(new_page);
+    }
+  }
+
+  // Bail if we had a memory allocation failure.
+  if (UNLIKELY(!new_page)) {
+    DCHECK(this->active_pages_head == PartitionPage::get_sentinel_page());
+    if (return_null)
+      return nullptr;
+    root->OutOfMemory();
+  }
+
+  // TODO(ajwong): Is there a way to avoid the reading of bucket here?
+  // It seems like in many of the conditional branches above, |this| ==
+  // |new_page->bucket|. Maybe pull this into another function?
+  PartitionBucket* bucket = new_page->bucket;
+  DCHECK(bucket != get_sentinel_bucket());
+  bucket->active_pages_head = new_page;
+  new_page->set_raw_size(size);
+
+  // If we found an active page with free slots, or an empty page, we have a
+  // usable freelist head.
+  if (LIKELY(new_page->freelist_head != nullptr)) {
+    PartitionFreelistEntry* entry = new_page->freelist_head;
+    PartitionFreelistEntry* new_head =
+        PartitionFreelistEntry::Transform(entry->next);
+    new_page->freelist_head = new_head;
+    new_page->num_allocated_slots++;
+    return entry;
+  }
+  // Otherwise, we need to build the freelist.
+  DCHECK(new_page->num_unprovisioned_slots);
+  return AllocAndFillFreelist(new_page);
+}
+
+}  // namespace internal
+}  // namespace base
diff --git a/base/allocator/partition_allocator/partition_bucket.h b/base/allocator/partition_allocator/partition_bucket.h
new file mode 100644
index 0000000..ec99174
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_bucket.h
@@ -0,0 +1,122 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+#include "base/base_export.h"
+#include "base/compiler_specific.h"
+
+namespace base {
+namespace internal {
+
+struct PartitionPage;
+struct PartitionRootBase;
+
+struct PartitionBucket {
+  // Accessed most in hot path => goes first.
+  PartitionPage* active_pages_head;
+
+  PartitionPage* empty_pages_head;
+  PartitionPage* decommitted_pages_head;
+  uint32_t slot_size;
+  uint32_t num_system_pages_per_slot_span : 8;
+  uint32_t num_full_pages : 24;
+
+  // Public API.
+  void Init(uint32_t new_slot_size);
+
+  // Note the matching Free() functions are in PartitionPage.
+  BASE_EXPORT void* Alloc(PartitionRootBase* root, int flags, size_t size);
+  BASE_EXPORT NOINLINE void* SlowPathAlloc(PartitionRootBase* root,
+                                           int flags,
+                                           size_t size);
+
+  ALWAYS_INLINE bool is_direct_mapped() const {
+    return !num_system_pages_per_slot_span;
+  }
+  ALWAYS_INLINE size_t get_bytes_per_span() const {
+    // TODO(ajwong): Change to CheckedMul. https://crbug.com/787153
+    // https://crbug.com/680657
+    return num_system_pages_per_slot_span * kSystemPageSize;
+  }
+  ALWAYS_INLINE uint16_t get_slots_per_span() const {
+    // TODO(ajwong): Change to CheckedMul. https://crbug.com/787153
+    // https://crbug.com/680657
+    return static_cast<uint16_t>(get_bytes_per_span() / slot_size);
+  }
+
+  static ALWAYS_INLINE size_t get_direct_map_size(size_t size) {
+    // Caller must check that the size is not above the kGenericMaxDirectMapped
+    // limit before calling. This also guards against integer overflow in the
+    // calculation here.
+    DCHECK(size <= kGenericMaxDirectMapped);
+    return (size + kSystemPageOffsetMask) & kSystemPageBaseMask;
+  }
+
+  // TODO(ajwong): Can this be made private?  https://crbug.com/787153
+  static PartitionBucket* get_sentinel_bucket();
+
+  // This helper function scans a bucket's active page list for a suitable new
+  // active page.  When it finds a suitable new active page (one that has
+  // free slots and is not empty), it is set as the new active page. If there
+  // is no suitable new active page, the current active page is set to
+  // PartitionPage::get_sentinel_page(). As potential pages are scanned, they
+  // are tidied up according to their state. Empty pages are swept on to the
+  // empty page list, decommitted pages on to the decommitted page list and full
+  // pages are unlinked from any list.
+  //
+  // This is where the guts of the bucket maintenance is done!
+  bool SetNewActivePage();
+
+ private:
+  static void OutOfMemory(const PartitionRootBase* root);
+  static void OutOfMemoryWithLotsOfUncommitedPages();
+
+  static NOINLINE void OnFull();
+
+  // Returns a natural number of PartitionPages (calculated by
+  // get_system_pages_per_slot_span()) to allocate from the current
+  // SuperPage when the bucket runs out of slots.
+  ALWAYS_INLINE uint16_t get_pages_per_slot_span();
+
+  // Returns the number of system pages in a slot span.
+  //
+  // The calculation attemps to find the best number of System Pages to
+  // allocate for the given slot_size to minimize wasted space. It uses a
+  // heuristic that looks at number of bytes wasted after the last slot and
+  // attempts to account for the PTE usage of each System Page.
+  uint8_t get_system_pages_per_slot_span();
+
+  // Allocates a new slot span with size |num_partition_pages| from the
+  // current extent. Metadata within this slot span will be uninitialized.
+  // Returns nullptr on error.
+  ALWAYS_INLINE void* AllocNewSlotSpan(PartitionRootBase* root,
+                                       int flags,
+                                       uint16_t num_partition_pages);
+
+  // Each bucket allocates a slot span when it runs out of slots.
+  // A slot span's size is equal to get_pages_per_slot_span() number of
+  // PartitionPages. This function initializes all PartitionPage within the
+  // span to point to the first PartitionPage which holds all the metadata
+  // for the span and registers this bucket as the owner of the span. It does
+  // NOT put the slots into the bucket's freelist.
+  ALWAYS_INLINE void InitializeSlotSpan(PartitionPage* page);
+
+  // Allocates one slot from the given |page| and then adds the remainder to
+  // the current bucket. If the |page| was freshly allocated, it must have been
+  // passed through InitializeSlotSpan() first.
+  ALWAYS_INLINE char* AllocAndFillFreelist(PartitionPage* page);
+
+  static PartitionBucket sentinel_bucket_;
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_BUCKET_H_
diff --git a/base/allocator/partition_allocator/partition_cookie.h b/base/allocator/partition_allocator/partition_cookie.h
new file mode 100644
index 0000000..8e6cb20
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_cookie.h
@@ -0,0 +1,72 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_COOKIE_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_COOKIE_H_
+
+#include "base/compiler_specific.h"
+#include "base/logging.h"
+
+namespace base {
+namespace internal {
+
+#if DCHECK_IS_ON()
+// These two byte values match tcmalloc.
+static const unsigned char kUninitializedByte = 0xAB;
+static const unsigned char kFreedByte = 0xCD;
+static const size_t kCookieSize =
+    16;  // Handles alignment up to XMM instructions on Intel.
+static const unsigned char kCookieValue[kCookieSize] = {
+    0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xD0, 0x0D,
+    0x13, 0x37, 0xF0, 0x05, 0xBA, 0x11, 0xAB, 0x1E};
+#endif
+
+ALWAYS_INLINE void PartitionCookieCheckValue(void* ptr) {
+#if DCHECK_IS_ON()
+  unsigned char* cookie_ptr = reinterpret_cast<unsigned char*>(ptr);
+  for (size_t i = 0; i < kCookieSize; ++i, ++cookie_ptr)
+    DCHECK(*cookie_ptr == kCookieValue[i]);
+#endif
+}
+
+ALWAYS_INLINE size_t PartitionCookieSizeAdjustAdd(size_t size) {
+#if DCHECK_IS_ON()
+  // Add space for cookies, checking for integer overflow. TODO(palmer):
+  // Investigate the performance and code size implications of using
+  // CheckedNumeric throughout PA.
+  DCHECK(size + (2 * kCookieSize) > size);
+  size += 2 * kCookieSize;
+#endif
+  return size;
+}
+
+ALWAYS_INLINE void* PartitionCookieFreePointerAdjust(void* ptr) {
+#if DCHECK_IS_ON()
+  // The value given to the application is actually just after the cookie.
+  ptr = static_cast<char*>(ptr) - kCookieSize;
+#endif
+  return ptr;
+}
+
+ALWAYS_INLINE size_t PartitionCookieSizeAdjustSubtract(size_t size) {
+#if DCHECK_IS_ON()
+  // Remove space for cookies.
+  DCHECK(size >= 2 * kCookieSize);
+  size -= 2 * kCookieSize;
+#endif
+  return size;
+}
+
+ALWAYS_INLINE void PartitionCookieWriteValue(void* ptr) {
+#if DCHECK_IS_ON()
+  unsigned char* cookie_ptr = reinterpret_cast<unsigned char*>(ptr);
+  for (size_t i = 0; i < kCookieSize; ++i, ++cookie_ptr)
+    *cookie_ptr = kCookieValue[i];
+#endif
+}
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_COOKIE_H_
diff --git a/base/allocator/partition_allocator/partition_direct_map_extent-inl.h b/base/allocator/partition_allocator/partition_direct_map_extent-inl.h
new file mode 100644
index 0000000..2cd3e32
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_direct_map_extent-inl.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_INL_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_INL_H_
+
+#include "base/allocator/partition_allocator/partition_bucket.h"
+#include "base/allocator/partition_allocator/partition_direct_map_extent.h"
+#include "base/allocator/partition_allocator/partition_page.h"
+
+namespace base {
+namespace internal {
+
+ALWAYS_INLINE PartitionDirectMapExtent* PartitionDirectMapExtent::FromPage(
+    PartitionPage* page) {
+  DCHECK(page->bucket->is_direct_mapped());
+  return reinterpret_cast<PartitionDirectMapExtent*>(
+      reinterpret_cast<char*>(page) + 3 * kPageMetadataSize);
+}
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_INL_H_
diff --git a/base/allocator/partition_allocator/partition_direct_map_extent.h b/base/allocator/partition_allocator/partition_direct_map_extent.h
new file mode 100644
index 0000000..f0045bd
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_direct_map_extent.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_H_
+
+namespace base {
+namespace internal {
+
+struct PartitionBucket;
+struct PartitionPage;
+
+struct PartitionDirectMapExtent {
+  PartitionDirectMapExtent* next_extent;
+  PartitionDirectMapExtent* prev_extent;
+  PartitionBucket* bucket;
+  size_t map_size;  // Mapped size, not including guard pages and meta-data.
+
+  ALWAYS_INLINE static PartitionDirectMapExtent* FromPage(PartitionPage* page);
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_DIRECT_MAP_EXTENT_H_
diff --git a/base/allocator/partition_allocator/partition_freelist_entry.h b/base/allocator/partition_allocator/partition_freelist_entry.h
new file mode 100644
index 0000000..7e3282e
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_freelist_entry.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_FREELIST_ENTRY_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_FREELIST_ENTRY_H_
+
+#include <stdint.h>
+
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+#include "base/compiler_specific.h"
+#include "base/sys_byteorder.h"
+#include "build/build_config.h"
+
+namespace base {
+namespace internal {
+
+// TODO(ajwong): Introduce an EncodedFreelistEntry type and then replace
+// Transform() with Encode()/Decode() such that the API provides some static
+// type safety.
+//
+// https://crbug.com/787153
+struct PartitionFreelistEntry {
+  PartitionFreelistEntry* next;
+
+  static ALWAYS_INLINE PartitionFreelistEntry* Transform(
+      PartitionFreelistEntry* ptr) {
+// We use bswap on little endian as a fast mask for two reasons:
+// 1) If an object is freed and its vtable used where the attacker doesn't
+// get the chance to run allocations between the free and use, the vtable
+// dereference is likely to fault.
+// 2) If the attacker has a linear buffer overflow and elects to try and
+// corrupt a freelist pointer, partial pointer overwrite attacks are
+// thwarted.
+// For big endian, similar guarantees are arrived at with a negation.
+#if defined(ARCH_CPU_BIG_ENDIAN)
+    uintptr_t masked = ~reinterpret_cast<uintptr_t>(ptr);
+#else
+    uintptr_t masked = ByteSwapUintPtrT(reinterpret_cast<uintptr_t>(ptr));
+#endif
+    return reinterpret_cast<PartitionFreelistEntry*>(masked);
+  }
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_FREELIST_ENTRY_H_
diff --git a/base/allocator/partition_allocator/partition_oom.cc b/base/allocator/partition_allocator/partition_oom.cc
new file mode 100644
index 0000000..5e1cf79
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_oom.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/allocator/partition_allocator/partition_oom.h"
+
+#include "base/allocator/partition_allocator/oom.h"
+#include "build/build_config.h"
+
+namespace base {
+namespace internal {
+
+void NOINLINE PartitionExcessiveAllocationSize() {
+  OOM_CRASH();
+}
+
+#if !defined(ARCH_CPU_64_BITS)
+NOINLINE void PartitionOutOfMemoryWithLotsOfUncommitedPages() {
+  OOM_CRASH();
+}
+#endif
+
+}  // namespace internal
+}  // namespace base
diff --git a/base/allocator/partition_allocator/partition_oom.h b/base/allocator/partition_allocator/partition_oom.h
new file mode 100644
index 0000000..da8fc15a
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_oom.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Holds functions for generating OOM errors from PartitionAlloc. This is
+// distinct from oom.h in that it is meant only for use in PartitionAlloc.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_OOM_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_OOM_H_
+
+#include "base/compiler_specific.h"
+#include "build/build_config.h"
+
+namespace base {
+namespace internal {
+
+NOINLINE void PartitionExcessiveAllocationSize();
+
+#if !defined(ARCH_CPU_64_BITS)
+NOINLINE void PartitionOutOfMemoryWithLotsOfUncommitedPages();
+#endif
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_OOM_H_
diff --git a/base/allocator/partition_allocator/partition_page-inl.h b/base/allocator/partition_allocator/partition_page-inl.h
new file mode 100644
index 0000000..4f2a646
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_page-inl.h
@@ -0,0 +1,194 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_INL_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_INL_H_
+
+#include "base/allocator/partition_allocator/partition_bucket.h"
+#include "base/allocator/partition_allocator/partition_cookie.h"
+#include "base/allocator/partition_allocator/partition_freelist_entry.h"
+#include "base/allocator/partition_allocator/partition_page.h"
+#include "base/allocator/partition_allocator/partition_root_base.h"
+
+namespace base {
+namespace internal {
+
+ALWAYS_INLINE char* PartitionSuperPageToMetadataArea(char* ptr) {
+  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(ptr);
+  DCHECK(!(pointer_as_uint & kSuperPageOffsetMask));
+  // The metadata area is exactly one system page (the guard page) into the
+  // super page.
+  return reinterpret_cast<char*>(pointer_as_uint + kSystemPageSize);
+}
+
+ALWAYS_INLINE PartitionPage* PartitionPage::FromPointerNoAlignmentCheck(
+    void* ptr) {
+  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(ptr);
+  char* super_page_ptr =
+      reinterpret_cast<char*>(pointer_as_uint & kSuperPageBaseMask);
+  uintptr_t partition_page_index =
+      (pointer_as_uint & kSuperPageOffsetMask) >> kPartitionPageShift;
+  // Index 0 is invalid because it is the metadata and guard area and
+  // the last index is invalid because it is a guard page.
+  DCHECK(partition_page_index);
+  DCHECK(partition_page_index < kNumPartitionPagesPerSuperPage - 1);
+  PartitionPage* page = reinterpret_cast<PartitionPage*>(
+      PartitionSuperPageToMetadataArea(super_page_ptr) +
+      (partition_page_index << kPageMetadataShift));
+  // Partition pages in the same slot span can share the same page object.
+  // Adjust for that.
+  size_t delta = page->page_offset << kPageMetadataShift;
+  page =
+      reinterpret_cast<PartitionPage*>(reinterpret_cast<char*>(page) - delta);
+  return page;
+}
+
+// Resturns start of the slot span for the PartitionPage.
+ALWAYS_INLINE void* PartitionPage::ToPointer(const PartitionPage* page) {
+  uintptr_t pointer_as_uint = reinterpret_cast<uintptr_t>(page);
+
+  uintptr_t super_page_offset = (pointer_as_uint & kSuperPageOffsetMask);
+
+  // A valid |page| must be past the first guard System page and within
+  // the following metadata region.
+  DCHECK(super_page_offset > kSystemPageSize);
+  // Must be less than total metadata region.
+  DCHECK(super_page_offset < kSystemPageSize + (kNumPartitionPagesPerSuperPage *
+                                                kPageMetadataSize));
+  uintptr_t partition_page_index =
+      (super_page_offset - kSystemPageSize) >> kPageMetadataShift;
+  // Index 0 is invalid because it is the superpage extent metadata and the
+  // last index is invalid because the whole PartitionPage is set as guard
+  // pages for the metadata region.
+  DCHECK(partition_page_index);
+  DCHECK(partition_page_index < kNumPartitionPagesPerSuperPage - 1);
+  uintptr_t super_page_base = (pointer_as_uint & kSuperPageBaseMask);
+  void* ret = reinterpret_cast<void*>(
+      super_page_base + (partition_page_index << kPartitionPageShift));
+  return ret;
+}
+
+ALWAYS_INLINE PartitionPage* PartitionPage::FromPointer(void* ptr) {
+  PartitionPage* page = PartitionPage::FromPointerNoAlignmentCheck(ptr);
+  // Checks that the pointer is a multiple of bucket size.
+  DCHECK(!((reinterpret_cast<uintptr_t>(ptr) -
+            reinterpret_cast<uintptr_t>(PartitionPage::ToPointer(page))) %
+           page->bucket->slot_size));
+  return page;
+}
+
+ALWAYS_INLINE const size_t* PartitionPage::get_raw_size_ptr() const {
+  // For single-slot buckets which span more than one partition page, we
+  // have some spare metadata space to store the raw allocation size. We
+  // can use this to report better statistics.
+  if (bucket->slot_size <= kMaxSystemPagesPerSlotSpan * kSystemPageSize)
+    return nullptr;
+
+  DCHECK((bucket->slot_size % kSystemPageSize) == 0);
+  DCHECK(bucket->is_direct_mapped() || bucket->get_slots_per_span() == 1);
+
+  const PartitionPage* the_next_page = this + 1;
+  return reinterpret_cast<const size_t*>(&the_next_page->freelist_head);
+}
+
+ALWAYS_INLINE size_t PartitionPage::get_raw_size() const {
+  const size_t* ptr = get_raw_size_ptr();
+  if (UNLIKELY(ptr != nullptr))
+    return *ptr;
+  return 0;
+}
+
+ALWAYS_INLINE bool PartitionPage::IsPointerValid(PartitionPage* page) {
+  PartitionRootBase* root = PartitionRootBase::FromPage(page);
+  return root->inverted_self == ~reinterpret_cast<uintptr_t>(root);
+}
+
+ALWAYS_INLINE void PartitionPage::Free(void* ptr) {
+// If these asserts fire, you probably corrupted memory.
+#if DCHECK_IS_ON()
+  size_t slot_size = this->bucket->slot_size;
+  size_t raw_size = get_raw_size();
+  if (raw_size)
+    slot_size = raw_size;
+  PartitionCookieCheckValue(ptr);
+  PartitionCookieCheckValue(reinterpret_cast<char*>(ptr) + slot_size -
+                            kCookieSize);
+  memset(ptr, kFreedByte, slot_size);
+#endif
+  DCHECK(this->num_allocated_slots);
+  // TODO(palmer): See if we can afford to make this a CHECK.
+  DCHECK(!freelist_head || PartitionPage::IsPointerValid(
+                               PartitionPage::FromPointer(freelist_head)));
+  CHECK(ptr != freelist_head);  // Catches an immediate double free.
+  // Look for double free one level deeper in debug.
+  DCHECK(!freelist_head || ptr != internal::PartitionFreelistEntry::Transform(
+                                      freelist_head->next));
+  internal::PartitionFreelistEntry* entry =
+      static_cast<internal::PartitionFreelistEntry*>(ptr);
+  entry->next = internal::PartitionFreelistEntry::Transform(freelist_head);
+  freelist_head = entry;
+  --this->num_allocated_slots;
+  if (UNLIKELY(this->num_allocated_slots <= 0)) {
+    FreeSlowPath();
+  } else {
+    // All single-slot allocations must go through the slow path to
+    // correctly update the size metadata.
+    DCHECK(get_raw_size() == 0);
+  }
+}
+
+ALWAYS_INLINE bool PartitionPage::is_active() const {
+  DCHECK(this != get_sentinel_page());
+  DCHECK(!page_offset);
+  return (num_allocated_slots > 0 &&
+          (freelist_head || num_unprovisioned_slots));
+}
+
+ALWAYS_INLINE bool PartitionPage::is_full() const {
+  DCHECK(this != get_sentinel_page());
+  DCHECK(!page_offset);
+  bool ret = (num_allocated_slots == bucket->get_slots_per_span());
+  if (ret) {
+    DCHECK(!freelist_head);
+    DCHECK(!num_unprovisioned_slots);
+  }
+  return ret;
+}
+
+ALWAYS_INLINE bool PartitionPage::is_empty() const {
+  DCHECK(this != get_sentinel_page());
+  DCHECK(!page_offset);
+  return (!num_allocated_slots && freelist_head);
+}
+
+ALWAYS_INLINE bool PartitionPage::is_decommitted() const {
+  DCHECK(this != get_sentinel_page());
+  DCHECK(!page_offset);
+  bool ret = (!num_allocated_slots && !freelist_head);
+  if (ret) {
+    DCHECK(!num_unprovisioned_slots);
+    DCHECK(empty_cache_index == -1);
+  }
+  return ret;
+}
+
+ALWAYS_INLINE void PartitionPage::set_raw_size(size_t size) {
+  size_t* raw_size_ptr = get_raw_size_ptr();
+  if (UNLIKELY(raw_size_ptr != nullptr))
+    *raw_size_ptr = size;
+}
+
+ALWAYS_INLINE void PartitionPage::Reset() {
+  DCHECK(this->is_decommitted());
+
+  num_unprovisioned_slots = bucket->get_slots_per_span();
+  DCHECK(num_unprovisioned_slots);
+
+  next_page = nullptr;
+}
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_INL_H_
diff --git a/base/allocator/partition_allocator/partition_page.cc b/base/allocator/partition_allocator/partition_page.cc
new file mode 100644
index 0000000..a8701b1
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_page.cc
@@ -0,0 +1,162 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/allocator/partition_allocator/partition_direct_map_extent-inl.h"
+#include "base/allocator/partition_allocator/partition_page-inl.h"
+#include "base/allocator/partition_allocator/partition_root_base-inl.h"
+
+namespace base {
+namespace internal {
+
+namespace {
+
+ALWAYS_INLINE void PartitionDirectUnmap(PartitionPage* page) {
+  PartitionRootBase* root = PartitionRootBase::FromPage(page);
+  const PartitionDirectMapExtent* extent =
+      PartitionDirectMapExtent::FromPage(page);
+  size_t unmap_size = extent->map_size;
+
+  // Maintain the doubly-linked list of all direct mappings.
+  if (extent->prev_extent) {
+    DCHECK(extent->prev_extent->next_extent == extent);
+    extent->prev_extent->next_extent = extent->next_extent;
+  } else {
+    root->direct_map_list = extent->next_extent;
+  }
+  if (extent->next_extent) {
+    DCHECK(extent->next_extent->prev_extent == extent);
+    extent->next_extent->prev_extent = extent->prev_extent;
+  }
+
+  // Add on the size of the trailing guard page and preceeding partition
+  // page.
+  unmap_size += kPartitionPageSize + kSystemPageSize;
+
+  size_t uncommitted_page_size = page->bucket->slot_size + kSystemPageSize;
+  root->DecreaseCommittedPages(uncommitted_page_size);
+  DCHECK(root->total_size_of_direct_mapped_pages >= uncommitted_page_size);
+  root->total_size_of_direct_mapped_pages -= uncommitted_page_size;
+
+  DCHECK(!(unmap_size & kPageAllocationGranularityOffsetMask));
+
+  char* ptr = reinterpret_cast<char*>(PartitionPage::ToPointer(page));
+  // Account for the mapping starting a partition page before the actual
+  // allocation address.
+  ptr -= kPartitionPageSize;
+
+  FreePages(ptr, unmap_size);
+}
+
+ALWAYS_INLINE void PartitionRegisterEmptyPage(PartitionPage* page) {
+  DCHECK(page->is_empty());
+  PartitionRootBase* root = PartitionRootBase::FromPage(page);
+
+  // If the page is already registered as empty, give it another life.
+  if (page->empty_cache_index != -1) {
+    DCHECK(page->empty_cache_index >= 0);
+    DCHECK(static_cast<unsigned>(page->empty_cache_index) < kMaxFreeableSpans);
+    DCHECK(root->global_empty_page_ring[page->empty_cache_index] == page);
+    root->global_empty_page_ring[page->empty_cache_index] = nullptr;
+  }
+
+  int16_t current_index = root->global_empty_page_ring_index;
+  PartitionPage* page_to_decommit = root->global_empty_page_ring[current_index];
+  // The page might well have been re-activated, filled up, etc. before we get
+  // around to looking at it here.
+  if (page_to_decommit)
+    page_to_decommit->DecommitIfPossible(root);
+
+  // We put the empty slot span on our global list of "pages that were once
+  // empty". thus providing it a bit of breathing room to get re-used before
+  // we really free it. This improves performance, particularly on Mac OS X
+  // which has subpar memory management performance.
+  root->global_empty_page_ring[current_index] = page;
+  page->empty_cache_index = current_index;
+  ++current_index;
+  if (current_index == kMaxFreeableSpans)
+    current_index = 0;
+  root->global_empty_page_ring_index = current_index;
+}
+
+}  // namespace
+
+// static
+PartitionPage PartitionPage::sentinel_page_;
+
+PartitionPage* PartitionPage::get_sentinel_page() {
+  return &sentinel_page_;
+}
+
+void PartitionPage::FreeSlowPath() {
+  DCHECK(this != get_sentinel_page());
+  if (LIKELY(this->num_allocated_slots == 0)) {
+    // Page became fully unused.
+    if (UNLIKELY(bucket->is_direct_mapped())) {
+      PartitionDirectUnmap(this);
+      return;
+    }
+    // If it's the current active page, change it. We bounce the page to
+    // the empty list as a force towards defragmentation.
+    if (LIKELY(this == bucket->active_pages_head))
+      bucket->SetNewActivePage();
+    DCHECK(bucket->active_pages_head != this);
+
+    set_raw_size(0);
+    DCHECK(!get_raw_size());
+
+    PartitionRegisterEmptyPage(this);
+  } else {
+    DCHECK(!bucket->is_direct_mapped());
+    // Ensure that the page is full. That's the only valid case if we
+    // arrive here.
+    DCHECK(this->num_allocated_slots < 0);
+    // A transition of num_allocated_slots from 0 to -1 is not legal, and
+    // likely indicates a double-free.
+    CHECK(this->num_allocated_slots != -1);
+    this->num_allocated_slots = -this->num_allocated_slots - 2;
+    DCHECK(this->num_allocated_slots == bucket->get_slots_per_span() - 1);
+    // Fully used page became partially used. It must be put back on the
+    // non-full page list. Also make it the current page to increase the
+    // chances of it being filled up again. The old current page will be
+    // the next page.
+    DCHECK(!this->next_page);
+    if (LIKELY(bucket->active_pages_head != get_sentinel_page()))
+      this->next_page = bucket->active_pages_head;
+    bucket->active_pages_head = this;
+    --bucket->num_full_pages;
+    // Special case: for a partition page with just a single slot, it may
+    // now be empty and we want to run it through the empty logic.
+    if (UNLIKELY(this->num_allocated_slots == 0))
+      FreeSlowPath();
+  }
+}
+
+void PartitionPage::Decommit(PartitionRootBase* root) {
+  DCHECK(is_empty());
+  DCHECK(!bucket->is_direct_mapped());
+  void* addr = PartitionPage::ToPointer(this);
+  root->DecommitSystemPages(addr, bucket->get_bytes_per_span());
+
+  // We actually leave the decommitted page in the active list. We'll sweep
+  // it on to the decommitted page list when we next walk the active page
+  // list.
+  // Pulling this trick enables us to use a singly-linked page list for all
+  // cases, which is critical in keeping the page metadata structure down to
+  // 32 bytes in size.
+  freelist_head = nullptr;
+  num_unprovisioned_slots = 0;
+  DCHECK(is_decommitted());
+}
+
+void PartitionPage::DecommitIfPossible(PartitionRootBase* root) {
+  DCHECK(empty_cache_index >= 0);
+  DCHECK(static_cast<unsigned>(empty_cache_index) < kMaxFreeableSpans);
+  DCHECK(this == root->global_empty_page_ring[empty_cache_index]);
+  empty_cache_index = -1;
+  if (is_empty())
+    Decommit(root);
+}
+
+}  // namespace internal
+}  // namespace base
diff --git a/base/allocator/partition_allocator/partition_page.h b/base/allocator/partition_allocator/partition_page.h
new file mode 100644
index 0000000..ed03b69
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_page.h
@@ -0,0 +1,118 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_H_
+
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+
+namespace base {
+namespace internal {
+
+struct PartitionBucket;
+struct PartitionFreelistEntry;
+struct PartitionRootBase;
+
+// Some notes on page states. A page can be in one of four major states:
+// 1) Active.
+// 2) Full.
+// 3) Empty.
+// 4) Decommitted.
+// An active page has available free slots. A full page has no free slots. An
+// empty page has no free slots, and a decommitted page is an empty page that
+// had its backing memory released back to the system.
+// There are two linked lists tracking the pages. The "active page" list is an
+// approximation of a list of active pages. It is an approximation because
+// full, empty and decommitted pages may briefly be present in the list until
+// we next do a scan over it.
+// The "empty page" list is an accurate list of pages which are either empty
+// or decommitted.
+//
+// The significant page transitions are:
+// - free() will detect when a full page has a slot free()'d and immediately
+// return the page to the head of the active list.
+// - free() will detect when a page is fully emptied. It _may_ add it to the
+// empty list or it _may_ leave it on the active list until a future list scan.
+// - malloc() _may_ scan the active page list in order to fulfil the request.
+// If it does this, full, empty and decommitted pages encountered will be
+// booted out of the active list. If there are no suitable active pages found,
+// an empty or decommitted page (if one exists) will be pulled from the empty
+// list on to the active list.
+//
+// TODO(ajwong): Evaluate if this should be named PartitionSlotSpanMetadata or
+// similar. If so, all uses of the term "page" in comments, member variables,
+// local variables, and documentation that refer to this concept should be
+// updated.
+struct PartitionPage {
+  PartitionFreelistEntry* freelist_head;
+  PartitionPage* next_page;
+  PartitionBucket* bucket;
+  // Deliberately signed, 0 for empty or decommitted page, -n for full pages:
+  int16_t num_allocated_slots;
+  uint16_t num_unprovisioned_slots;
+  uint16_t page_offset;
+  int16_t empty_cache_index;  // -1 if not in the empty cache.
+
+  // Public API
+
+  // Note the matching Alloc() functions are in PartitionPage.
+  BASE_EXPORT NOINLINE void FreeSlowPath();
+  ALWAYS_INLINE void Free(void* ptr);
+
+  void Decommit(PartitionRootBase* root);
+  void DecommitIfPossible(PartitionRootBase* root);
+
+  // Pointer manipulation functions. These must be static as the input |page|
+  // pointer may be the result of an offset calculation and therefore cannot
+  // be trusted. The objective of these functions is to sanitize this input.
+  ALWAYS_INLINE static void* ToPointer(const PartitionPage* page);
+  ALWAYS_INLINE static PartitionPage* FromPointerNoAlignmentCheck(void* ptr);
+  ALWAYS_INLINE static PartitionPage* FromPointer(void* ptr);
+  ALWAYS_INLINE static bool IsPointerValid(PartitionPage* page);
+
+  ALWAYS_INLINE const size_t* get_raw_size_ptr() const;
+  ALWAYS_INLINE size_t* get_raw_size_ptr() {
+    return const_cast<size_t*>(
+        const_cast<const PartitionPage*>(this)->get_raw_size_ptr());
+  }
+
+  ALWAYS_INLINE size_t get_raw_size() const;
+  ALWAYS_INLINE void set_raw_size(size_t size);
+
+  ALWAYS_INLINE void Reset();
+
+  // TODO(ajwong): Can this be made private?  https://crbug.com/787153
+  BASE_EXPORT static PartitionPage* get_sentinel_page();
+
+  // Page State accessors.
+  // Note that it's only valid to call these functions on pages found on one of
+  // the page lists. Specifically, you can't call these functions on full pages
+  // that were detached from the active list.
+  //
+  // This restriction provides the flexibity for some of the status fields to
+  // be repurposed when a page is taken off a list. See the negation of
+  // |num_allocated_slots| when a full page is removed from the active list
+  // for an example of such repurposing.
+  ALWAYS_INLINE bool is_active() const;
+  ALWAYS_INLINE bool is_full() const;
+  ALWAYS_INLINE bool is_empty() const;
+  ALWAYS_INLINE bool is_decommitted() const;
+
+ private:
+  // g_sentinel_page is used as a sentinel to indicate that there is no page
+  // in the active page list. We can use nullptr, but in that case we need
+  // to add a null-check branch to the hot allocation path. We want to avoid
+  // that.
+  //
+  // Note, this declaration is kept in the header as opposed to an anonymous
+  // namespace so the getter can be fully inlined.
+  static PartitionPage sentinel_page_;
+};
+static_assert(sizeof(PartitionPage) <= kPageMetadataSize,
+              "PartitionPage must be able to fit in a metadata slot");
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_PAGE_H_
diff --git a/base/allocator/partition_allocator/partition_root_base-inl.h b/base/allocator/partition_allocator/partition_root_base-inl.h
new file mode 100644
index 0000000..ed0cb0c
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_root_base-inl.h
@@ -0,0 +1,49 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_INL_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_INL_H_
+
+#include "base/allocator/partition_allocator/page_allocator.h"
+#include "base/allocator/partition_allocator/partition_root_base.h"
+
+namespace base {
+namespace internal {
+
+ALWAYS_INLINE PartitionRootBase* PartitionRootBase::FromPage(
+    PartitionPage* page) {
+  PartitionSuperPageExtentEntry* extent_entry =
+      reinterpret_cast<PartitionSuperPageExtentEntry*>(
+          reinterpret_cast<uintptr_t>(page) & kSystemPageBaseMask);
+  return extent_entry->root;
+}
+
+ALWAYS_INLINE void PartitionRootBase::IncreaseCommittedPages(size_t len) {
+  total_size_of_committed_pages += len;
+  DCHECK(total_size_of_committed_pages <=
+         total_size_of_super_pages + total_size_of_direct_mapped_pages);
+}
+
+ALWAYS_INLINE void PartitionRootBase::DecreaseCommittedPages(size_t len) {
+  total_size_of_committed_pages -= len;
+  DCHECK(total_size_of_committed_pages <=
+         total_size_of_super_pages + total_size_of_direct_mapped_pages);
+}
+
+ALWAYS_INLINE void PartitionRootBase::DecommitSystemPages(void* address,
+                                                          size_t length) {
+  ::base::DecommitSystemPages(address, length);
+  DecreaseCommittedPages(length);
+}
+
+ALWAYS_INLINE void PartitionRootBase::RecommitSystemPages(void* address,
+                                                          size_t length) {
+  CHECK(::base::RecommitSystemPages(address, length, PageReadWrite));
+  IncreaseCommittedPages(length);
+}
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_INL_H_
diff --git a/base/allocator/partition_allocator/partition_root_base.cc b/base/allocator/partition_allocator/partition_root_base.cc
new file mode 100644
index 0000000..3c6050d
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_root_base.cc
@@ -0,0 +1,40 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/allocator/partition_allocator/partition_root_base-inl.h"
+
+#include "base/allocator/partition_allocator/oom.h"
+#include "base/allocator/partition_allocator/partition_oom.h"
+#include "base/allocator/partition_allocator/partition_page-inl.h"
+#include "build/build_config.h"
+
+namespace base {
+namespace internal {
+
+NOINLINE void PartitionRootBase::OutOfMemory() {
+#if !defined(ARCH_CPU_64_BITS)
+  // Check whether this OOM is due to a lot of super pages that are allocated
+  // but not committed, probably due to http://crbug.com/421387.
+  if (total_size_of_super_pages + total_size_of_direct_mapped_pages -
+          total_size_of_committed_pages >
+      kReasonableSizeOfUnusedPages) {
+    PartitionOutOfMemoryWithLotsOfUncommitedPages();
+  }
+#endif
+  if (PartitionRootBase::gOomHandlingFunction)
+    (*PartitionRootBase::gOomHandlingFunction)();
+  OOM_CRASH();
+}
+
+void PartitionRootBase::DecommitEmptyPages() {
+  for (size_t i = 0; i < kMaxFreeableSpans; ++i) {
+    internal::PartitionPage* page = global_empty_page_ring[i];
+    if (page)
+      page->DecommitIfPossible(this);
+    global_empty_page_ring[i] = nullptr;
+  }
+}
+
+}  // namespace internal
+}  // namespace base
diff --git a/base/allocator/partition_allocator/partition_root_base.h b/base/allocator/partition_allocator/partition_root_base.h
new file mode 100644
index 0000000..ed532a8
--- /dev/null
+++ b/base/allocator/partition_allocator/partition_root_base.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_H_
+#define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_H_
+
+#include "base/allocator/partition_allocator/partition_alloc_constants.h"
+#include "base/allocator/partition_allocator/partition_direct_map_extent.h"
+
+namespace base {
+namespace internal {
+
+struct PartitionPage;
+struct PartitionRootBase;
+
+// An "extent" is a span of consecutive superpages. We link to the partition's
+// next extent (if there is one) to the very start of a superpage's metadata
+// area.
+struct PartitionSuperPageExtentEntry {
+  PartitionRootBase* root;
+  char* super_page_base;
+  char* super_pages_end;
+  PartitionSuperPageExtentEntry* next;
+};
+static_assert(
+    sizeof(PartitionSuperPageExtentEntry) <= kPageMetadataSize,
+    "PartitionSuperPageExtentEntry must be able to fit in a metadata slot");
+
+struct BASE_EXPORT PartitionRootBase {
+  PartitionRootBase();
+  virtual ~PartitionRootBase();
+  size_t total_size_of_committed_pages = 0;
+  size_t total_size_of_super_pages = 0;
+  size_t total_size_of_direct_mapped_pages = 0;
+  // Invariant: total_size_of_committed_pages <=
+  //                total_size_of_super_pages +
+  //                total_size_of_direct_mapped_pages.
+  unsigned num_buckets = 0;
+  unsigned max_allocation = 0;
+  bool initialized = false;
+  char* next_super_page = nullptr;
+  char* next_partition_page = nullptr;
+  char* next_partition_page_end = nullptr;
+  PartitionSuperPageExtentEntry* current_extent = nullptr;
+  PartitionSuperPageExtentEntry* first_extent = nullptr;
+  PartitionDirectMapExtent* direct_map_list = nullptr;
+  PartitionPage* global_empty_page_ring[kMaxFreeableSpans] = {};
+  int16_t global_empty_page_ring_index = 0;
+  uintptr_t inverted_self = 0;
+
+  // Public API
+
+  // gOomHandlingFunction is invoked when PartitionAlloc hits OutOfMemory.
+  static void (*gOomHandlingFunction)();
+  NOINLINE void OutOfMemory();
+
+  ALWAYS_INLINE static PartitionRootBase* FromPage(PartitionPage* page);
+
+  ALWAYS_INLINE void IncreaseCommittedPages(size_t len);
+  ALWAYS_INLINE void DecreaseCommittedPages(size_t len);
+  ALWAYS_INLINE void DecommitSystemPages(void* address, size_t length);
+  ALWAYS_INLINE void RecommitSystemPages(void* address, size_t length);
+
+  void DecommitEmptyPages();
+};
+
+}  // namespace internal
+}  // namespace base
+
+#endif  // BASE_ALLOCATOR_PARTITION_ALLOCATOR_PARTITION_ROOT_BASE_H_
